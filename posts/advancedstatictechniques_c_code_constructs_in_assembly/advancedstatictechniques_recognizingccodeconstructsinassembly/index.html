<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Advanced Static Techniques - Recognizing C code constructs in Assembly - Pablo de Juan Fidalgo</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Notes Global vs. Local Variables Global variables are referenced by memory addresses, and the local variables are referenced by the stack addresses. Understanding Function Call Conventions cdecl is one of the most popular conventions. In cdecl, parameters are pushed onto the stack from right to left, the caller cleans up the stack when the function is complete, and the return value is stored in EAX. The popular stdcall convention is similar to cdecl, except stdcall requires the callee to clean up the stack when the function is complete."><meta property="og:image" content><meta property="og:title" content="Advanced Static Techniques - Recognizing C code constructs in Assembly"><meta property="og:description" content="Notes Global vs. Local Variables Global variables are referenced by memory addresses, and the local variables are referenced by the stack addresses. Understanding Function Call Conventions cdecl is one of the most popular conventions. In cdecl, parameters are pushed onto the stack from right to left, the caller cleans up the stack when the function is complete, and the return value is stored in EAX. The popular stdcall convention is similar to cdecl, except stdcall requires the callee to clean up the stack when the function is complete."><meta property="og:type" content="article"><meta property="og:url" content="https://pabdj.github.io/posts/advancedstatictechniques_c_code_constructs_in_assembly/advancedstatictechniques_recognizingccodeconstructsinassembly/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-24T14:15:58+05:30"><meta property="article:modified_time" content="2022-12-24T14:15:58+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advanced Static Techniques - Recognizing C code constructs in Assembly"><meta name=twitter:description content="Notes Global vs. Local Variables Global variables are referenced by memory addresses, and the local variables are referenced by the stack addresses. Understanding Function Call Conventions cdecl is one of the most popular conventions. In cdecl, parameters are pushed onto the stack from right to left, the caller cleans up the stack when the function is complete, and the return value is stored in EAX. The popular stdcall convention is similar to cdecl, except stdcall requires the callee to clean up the stack when the function is complete."><script src=https://pabdj.github.io/js/feather.min.js></script>
<link href=https://pabdj.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://pabdj.github.io/css/main.0fd5f05032e8d6d12808eb2d48a5a295f4ee5cd8eefd5bf3dbfd49a346d206ed.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://pabdj.github.io/css/dark.73617b6be66d271725422ddf83ec3f8c57af298005233c552735d43adf634f04.css disabled></head><body><div class=content><header><div class=main><a href=https://pabdj.github.io/>Pablo de Juan Fidalgo</a></div><nav><a href=/>Home</a>
<a href=/posts>Blog</a>
<a href=/tags>Tags</a>
| <a id=dark-mode-toggle onclick=toggleTheme() href></a>
<script src=https://pabdj.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Advanced Static Techniques - Recognizing C code constructs in Assembly</h1><div class=meta>Posted on Dec 24, 2022</div></div><section class=body><h2 id=notes>Notes</h2><h3 id=global-vs-local-variables>Global vs. Local Variables</h3><ul><li>Global variables are referenced by memory addresses, and the local variables are referenced by the stack addresses.</li></ul><h3 id=understanding-function-call-conventions>Understanding Function Call Conventions</h3><ul><li><em>cdecl</em> is one of the most popular conventions. In <em>cdecl</em>, parameters are pushed onto the stack from right to left, the caller cleans up the stack when the function is complete, and the return value is stored in EAX.</li><li>The popular <em>stdcall</em> convention is similar to <em>cdecl</em>, except <em>stdcall</em> requires the callee to clean up the stack when the function is complete.</li><li><em>stdcall</em> is the standard calling convention for the Windows API. Any code calling these API functions will not need to clean up the stack, since that‚Äôs the responsibility of the DLLs that implement the code for the API function.</li><li>In <em>fastcall</em>, the first few arguments (typically two) are passed in registers, with the most commonly used registers being EDX and ECX (the Microsoft fastcall convention). Additional arguments are loaded from right to left, and the calling function is usually responsible for cleaning up the stack, if necessary.</li><li>Microsoft Visual Studio <strong>pushes</strong> the parameters onto the stack and GNU Compiler Collection (GCC) <strong>moves</strong> the parameters onto the stack before the call.</li></ul><h2 id=labs>Labs</h2><p>This note is being written after struggling with Lab 1 and 2.
Long story short, I was getting confused with <strong>main</strong> vs <strong>entry point</strong> because neither Ghidra nor IDA Free v7.0 were landing on main. In fact, they were doing it on entry point but if we mix that I am still a noob and function <em>main</em> was not labelled we can end up in a rabbit hole.
As I am not an expert, I will leave this YouTube video that help me out with this issue.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/suwZB3EA_u4 style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><p>Taking into account the trick that <a href=https://twitter.com/herrcore>@herrcore</a> mentions in his video we have to search for three consecutive PUSH/MOV instructions, depending on whether we are working with x86 arch or x64.</p><table><thead><tr><th style=text-align:center>Ghidra</th><th style=text-align:center>IDA Free v8.1</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../Ghidra.PNG></figure></td><td style=text-align:center><figure><img src=../IDAFree.PNG></figure></td></tr></tbody></table><p>‚ö†Ô∏è <strong>DON&rsquo;T PANIC!</strong> IDA Free v8.1 works fine and detects <em>main</em> function without any problem, but I will always recommend to understand how things work instead of relying on any tool üòâ</p><h3 id=lab-1>Lab 1</h3><p><strong>1. What is the major code construct found in the only subroutine called by main?</strong></p><p>The subroutine is called at 0x401000. If we take a look at the function graph we can observe that it is an if statement.</p><p><strong>2. What is the subroutine located at 0x40105F?</strong></p><p>I have to admit that I fell in a rabbit hole with this question. When I gave up because I did not have any clue, I looked at the solutions and the answer was &ldquo;<em>printf</em>&rdquo;.</p><p>My mistake was to try to understand what the actual subroutine was doing instead of observing in what context it was called.
Below you can observe that in both screenshots my approach was to learn how the function worked.</p><table><thead><tr><th style=text-align:center>IDA Free</th><th style=text-align:center>Ghidra</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../6-1.PNG></figure></td><td style=text-align:center><figure><img src=../6-1-1.PNG></figure></td></tr></tbody></table><p>If you take a look at the cross-references of the function, you can observe that it is being used as a printf function.<figure><img src=../6-1-2.PNG></figure></p><figure><img src=../6-1-3.PNG></figure><p><strong>3. What is the purpose of this program?</strong></p><p>After taking a look at the strings, we can observe some suspicious ones like <em>Error 1.1. No Internet</em> and <em>Success: Internet Connection</em>. Apart from that, if we analyse the imports, we can think about some malicious capabilities. Some of them are: <em>VirtualAlloc</em>, <em>GetCurrentProcess</em>, <em>GetStartupInfoA</em>, etc.</p><p>With basic dynamic techniques we cannot observe anything clear, so we have to jump into disassembly.</p><p>In subroutine 0x401000, we see that <a href=https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetgetconnectedstate>InternetGetConnectedState</a> function is called. The program tries to receive information about the machine, in this case if it has network connection to the Internet.</p><h3 id=lab-2>Lab 2</h3><p><strong>1. What operation does the first subroutine called by main perform?</strong></p><p>IDA Free v8.1 directly lands on main but Ghidra, again, doesn&rsquo;t. In order to find main, as I mentioned before we have to find three consecutive PUSH instructions that involve EAX.</p><figure><img src=../6-2.PNG></figure><p>Once we have located main, we rename it, jump into it and find the subroutine.</p><p>The first subroutine in <em>main</em> is located at 0x401000, and it is an if statement.</p><p><strong>2. What is the subroutine located at 0x40117F?</strong></p><p>This function is the same one as Lab 1.2 answer, a printf function.</p><p><strong>3. What does the second subroutine called by main do?</strong></p><p>The second subroutine that is called is at 0x00401040. It tries to connect &ldquo;<em>hxxp://www.practicalmalwareanalysis.com/cc.htm</em>&rdquo; and tries to read a file in order to get a command.</p><p>The pictures below show the function graph.<figure><img src=../6-2-1.PNG></figure><figure><img src=../6-2-2.PNG></figure></p><p><strong>4. What type of code construct is used in this subroutine?</strong></p><p>It also uses an if statement.</p><p><strong>5. Are there any network-based indicators for this program?</strong></p><p>The main network-based indicator is the URL &ldquo;<em>hxxp://www.practicalmalwareanalysis.com/cc.htm</em>&rdquo;</p><p><strong>6. What is the purpose of this malware?</strong></p><p>This lab is a continuation of the sample Lab06-01.exe which checks if the machine has internet connection and if this call returns a successful confirmation, it tries to establish a connection with the URL mentioned before and gets some commands from there.</p><h3 id=lab-3>Lab 3</h3><p><strong>1. Compare the calls in main to Lab 6-2‚Äôs main method. What is the new function called from main?</strong></p><p>The new function is located at 0x401130.</p><p><strong>2. What parameters does this new function take?</strong></p><p>It takes two parameters. The first one is the return of subroutine at 0x401040 and if we observe that in the following line it is compared again the string &lsquo;\0&rsquo; and it prints out information related to a command, we can think that this parameter is linked to a command that the code receives from somewhere else.
Regarding the second parameter, it is the same one as the <em>main</em> function receives. Do you remember the classical *int main (int argc, char <em>argv)</em>? Here it is!</p><figure><img src=../6-2-3.PNG></figure><p><strong>3. What major code construct does this function contain?</strong></p><p>It contains a switch statement.<figure><img src=../6-2-4.PNG></figure></p><p><strong>4. What can this function do?</strong></p><p>It creates a directory which contains a file. In order to achieve persistence it copies itself into the registry and afterwards it deletes the file as a form of evasion.</p><p><strong>5. Are there any host-based indicators for this malware?</strong></p><p>There are some hardcoded paths like the ones shown in the image.<figure><img src=../6-2-5.PNG></figure></p><p><strong>6. What is the purpose of this malware?</strong></p><p>This malware checks if the machine has internet connection and if this call returns a successful confirmation, it tries to establish a connection with the URL mentioned before and gets some commands from there. Once they have been retrieved from the URL, they are used in order to create a directory which contains a file. For achieving persistence it copies itself into the registry and afterwards it deletes the file as a form of evasion.</p><h3 id=lab-4>Lab 4</h3><p><strong>1. What is the difference between the calls made from the main method in Labs 3 and 4?</strong></p><p>There is not a big difference between the two labs regarding the calls inside main.</p><table><thead><tr><th style=text-align:center>Lab 3</th><th style=text-align:center>Lab 4</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../6-3.PNG></figure></td><td style=text-align:center><figure><img src=../6-3-1.PNG></figure></td></tr></tbody></table><p><strong>2. What new code construct has been added to main?</strong></p><p>A while loop has been added to main.</p><p><strong>3. What is the difference between this lab‚Äôs parse HTML function and those of the previous labs?</strong></p><p>This function calls subroutine located at 0x4012E6 because Internet Agent is slightly different.</p><p><strong>4. How long will this program run? (Assume that it is connected to the Internet.)</strong></p><p>It will last for 1440 minutes which is the same as 24 hours. There are 1440 executions in the loop and each one is performed in 60 seconds.</p><figure><img src=../6-3-3.PNG></figure><p><strong>5. Are there any new network-based indicators for this malware?</strong></p><p>The User-Agent with Internet Explorer.<figure><img src=../6-3-4.PNG></figure></p><p><strong>6. What is the purpose of this malware?</strong></p><p>This malware checks if the machine has internet connection and if this call returns a successful confirmation, it tries to establish a connection with the URL mentioned before with a unique User-Agent and gets some commands from there. Once they have been retrieved from the URL, they are used in order to create a directory which contains a file. For achieving persistence it copies itself into the registry and afterwards it deletes the file as a form of evasion. The program&rsquo;s execution is 24 hours.</p></section><div class=post-tags><nav class="nav tags"><h2 class=title>Tags</h2><ul class=tags><li><a href=/tags/practical-malware-analysis>practical malware analysis</a></li><li><a href=/tags/malware>malware</a></li><li><a href=/tags/reversing>reversing</a></li><li><a href=/tags/advanced>advanced</a></li><li><a href=/tags/static>static</a></li><li><a href=/tags/analysis>analysis</a></li><li><a href=/tags/x86>x86</a></li><li><a href=/tags/x64>x64</a></li><li><a href=/tags/assembly>assembly</a></li><li><a href=/tags/registers>registers</a></li><li><a href=/tags/ida>ida</a></li><li><a href=/tags/ghidra>ghidra</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/pabdj title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/pabdjf title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=https://es.linkedin.com/in/pablodejuanfidalgo title=LinkedIn><i data-feather=linkedin></i></a>
<a class=border></a></div><div class=footer-info>2023 ¬© Pablo de Juan Fidalgo |</div></footer><script>feather.replace()</script></div></body></html>