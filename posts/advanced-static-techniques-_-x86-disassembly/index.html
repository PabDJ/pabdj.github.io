<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Advanced Static Techniques - x86 Disassembly - Pablo de Juan Fidalgo</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Table of Contents Opcodes and Endianness Registers General registers Simple instructions The Stack This blog post collects some notes that I took while reading PMA Chapter 4. As it was not the first time dealing with assembly most of the concepts rang a bell.
Opcodes and Endianness Network data uses big-endian and an x86 program uses little-endian. Therefore, the IP address 127.0.0.1 will be represented as 0x7F000001 in big endian format (over the network) and 0x0100007F in little-endian format (locally in memory)"><meta property="og:image" content><meta property="og:title" content="Advanced Static Techniques - x86 Disassembly"><meta property="og:description" content="Table of Contents Opcodes and Endianness Registers General registers Simple instructions The Stack This blog post collects some notes that I took while reading PMA Chapter 4. As it was not the first time dealing with assembly most of the concepts rang a bell.
Opcodes and Endianness Network data uses big-endian and an x86 program uses little-endian. Therefore, the IP address 127.0.0.1 will be represented as 0x7F000001 in big endian format (over the network) and 0x0100007F in little-endian format (locally in memory)"><meta property="og:type" content="article"><meta property="og:url" content="https://pabdj.github.io/posts/advanced-static-techniques-_-x86-disassembly/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-19T09:50:58+05:30"><meta property="article:modified_time" content="2022-12-19T09:50:58+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advanced Static Techniques - x86 Disassembly"><meta name=twitter:description content="Table of Contents Opcodes and Endianness Registers General registers Simple instructions The Stack This blog post collects some notes that I took while reading PMA Chapter 4. As it was not the first time dealing with assembly most of the concepts rang a bell.
Opcodes and Endianness Network data uses big-endian and an x86 program uses little-endian. Therefore, the IP address 127.0.0.1 will be represented as 0x7F000001 in big endian format (over the network) and 0x0100007F in little-endian format (locally in memory)"><script src=https://pabdj.github.io/js/feather.min.js></script>
<link href=https://pabdj.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://pabdj.github.io/css/main.0fd5f05032e8d6d12808eb2d48a5a295f4ee5cd8eefd5bf3dbfd49a346d206ed.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://pabdj.github.io/css/dark.73617b6be66d271725422ddf83ec3f8c57af298005233c552735d43adf634f04.css disabled></head><body><div class=content><header><div class=main><a href=https://pabdj.github.io/>Pablo de Juan Fidalgo</a></div><nav><a href=/>Home</a>
<a href=/posts>Blog</a>
<a href=/tags>Tags</a>
| <a id=dark-mode-toggle onclick=toggleTheme() href></a>
<script src=https://pabdj.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Advanced Static Techniques - x86 Disassembly</h1><div class=meta>Posted on Dec 19, 2022</div></div><section class=body><h2 id=table-of-contents>Table of Contents</h2><ol><li><a href=#opcodes-and-endianness>Opcodes and Endianness</a></li><li><a href=#registers>Registers</a><ol><li><a href=#general-registers>General registers</a></li><li><a href=#simple-instructions>Simple instructions</a></li><li><a href=#the-stack>The Stack</a></li></ol></li></ol><p>This blog post collects some notes that I took while reading PMA Chapter 4. As it was not the first time dealing with assembly most of the concepts rang a bell.</p><h2 id=opcodes-and-endianness>Opcodes and Endianness</h2><p>Network data uses big-endian and an x86 program uses little-endian.
Therefore, the IP address 127.0.0.1 will be represented as 0x7F000001 in big endian
format (over the network) and 0x0100007F in little-endian format (locally in memory)</p><h2 id=registers>Registers</h2><h3 id=general-registers>General registers</h3><p>Some x86 instructions use specific registers by definition.</p><ul><li>Multiplication and division instructions always use EAX and EDX.</li><li>EAX generally contains the return value for function calls.</li><li>EIP, the Instruction Pointer or program counter, is a register that contains the memory address of the next instruction to be executed for a program.</li></ul><h3 id=simple-instructions>Simple instructions</h3><ul><li>The <em>lea</em> instruction is used to put a memory address into the destination. For example, <code>lea eax, [ebx+8]</code> will put EBX+8 into EAX. In contrast, <code>mov eax, [ebx+8]</code> loads the data at the memory address specified by EBX+8. Therefore, <code>lea eax, [ebx+8]</code> would be the same as <code>mov eax, ebx+8</code>; however, a <em>mov</em> instruction like that is invalid. The lea instruction is not used exclusively to refer to memory addresses. It is useful when calculating values, because it requires fewer instructions.</li><li>Regarding <em>mul</em> instruction, the result is stored as a 64-bit value across two registers: EDX and EAX. EDX stores the most significant 32 bits of the operations, and EAX stores the least significant 32 bits.</li><li>The <em>div</em> instruction does the same thing as <em>mul</em>, except in the opposite direction: It divides the 64 bits across EDX and EAX by value. Therefore, the EDX and EAX registers must be set up appropriately before the division occurs. The result of the division operation is stored in EAX, and the remainder is stored in EDX.</li><li>During malware analysis, if you encounter a function containing only the instructions <em>xor</em>, <em>or</em>, <em>and</em>, <em>shl</em>, <em>ror</em>, <em>shr</em>, or <em>rol</em> repeatedly and seemingly randomly, you have probably encountered an <strong>encryption</strong> or <strong>compression function</strong>.</li></ul><h3 id=the-stack>The Stack</h3><p>x86 architecture provides additional instructions for popping and pushing, the most popular of which are <em>pusha</em> and <em>pushad</em>. These instructions push all the registers onto the stack and are commonly used with <em>popa</em> and <em>popad</em>, which pop all the registers off the stack. The <em>pusha</em> and <em>pushad</em> functions operate as follows:</p><ul><li><em>pusha</em> pushes the 16-bit registers on the stack in the following order: AX, CX, DX, BX, SP, BP, SI, DI.</li><li><em>pushad</em> pushes the 32-bit registers on the stack in the following order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI.
These instructions are typically encountered in shellcode when someone wants to save the current state of the registers to the stack so that they can be restored at a later time. Compilers rarely use these instructions, so seeing them often indicates someone <strong>hand-coded assembly and/or shellcode</strong>.</li></ul></section><div class=post-tags><nav class="nav tags"><h2 class=title>Tags</h2><ul class=tags><li><a href=/tags/practical-malware-analysis>practical malware analysis</a></li><li><a href=/tags/malware>malware</a></li><li><a href=/tags/reversing>reversing</a></li><li><a href=/tags/advanced>advanced</a></li><li><a href=/tags/static>static</a></li><li><a href=/tags/analysis>analysis</a></li><li><a href=/tags/x86>x86</a></li><li><a href=/tags/x64>x64</a></li><li><a href=/tags/assembly>assembly</a></li><li><a href=/tags/registers>registers</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/pabdj title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/pabdjf title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=https://es.linkedin.com/in/pablodejuanfidalgo title=LinkedIn><i data-feather=linkedin></i></a>
<a class=border></a></div><div class=footer-info>2023 Â© Pablo de Juan Fidalgo |</div></footer><script>feather.replace()</script></div></body></html>