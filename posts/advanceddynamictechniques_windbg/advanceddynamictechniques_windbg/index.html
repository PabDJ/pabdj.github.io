<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Advanced Dynamic Techniques - WinDbg - Pablo de Juan Fidalgo</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Table of Contents Notes Drivers and Kernel Code Setting Up Kernel Debugging Windows XP and x86 architecture Windows Vista, Windows 7, and x64 Versions Using WinDbg Microsoft Symbols Kernel Debugging in Practice User-space code Kernel-space code Loading Drivers Labs Lab 1 Lab 2 Lab 3 Notes Drivers and Kernel Code Drivers must be loaded into the kernel, just as DLLs are loaded into processes. When a driver is first loaded, its DriverEntry procedure is called, similar to DLLMain for DLLs."><meta property="og:image" content><meta property="og:title" content="Advanced Dynamic Techniques - WinDbg"><meta property="og:description" content="Table of Contents Notes Drivers and Kernel Code Setting Up Kernel Debugging Windows XP and x86 architecture Windows Vista, Windows 7, and x64 Versions Using WinDbg Microsoft Symbols Kernel Debugging in Practice User-space code Kernel-space code Loading Drivers Labs Lab 1 Lab 2 Lab 3 Notes Drivers and Kernel Code Drivers must be loaded into the kernel, just as DLLs are loaded into processes. When a driver is first loaded, its DriverEntry procedure is called, similar to DLLMain for DLLs."><meta property="og:type" content="article"><meta property="og:url" content="https://pabdj.github.io/posts/advanceddynamictechniques_windbg/advanceddynamictechniques_windbg/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-24T19:53:58+05:30"><meta property="article:modified_time" content="2023-03-24T19:53:58+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advanced Dynamic Techniques - WinDbg"><meta name=twitter:description content="Table of Contents Notes Drivers and Kernel Code Setting Up Kernel Debugging Windows XP and x86 architecture Windows Vista, Windows 7, and x64 Versions Using WinDbg Microsoft Symbols Kernel Debugging in Practice User-space code Kernel-space code Loading Drivers Labs Lab 1 Lab 2 Lab 3 Notes Drivers and Kernel Code Drivers must be loaded into the kernel, just as DLLs are loaded into processes. When a driver is first loaded, its DriverEntry procedure is called, similar to DLLMain for DLLs."><script src=https://pabdj.github.io/js/feather.min.js></script>
<link href=https://pabdj.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://pabdj.github.io/css/main.0fd5f05032e8d6d12808eb2d48a5a295f4ee5cd8eefd5bf3dbfd49a346d206ed.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://pabdj.github.io/css/dark.73617b6be66d271725422ddf83ec3f8c57af298005233c552735d43adf634f04.css disabled></head><body><div class=content><header><div class=main><a href=https://pabdj.github.io/>Pablo de Juan Fidalgo</a></div><nav><a href=/>Home</a>
<a href=/posts>Blog</a>
<a href=/tags>Tags</a>
| <a id=dark-mode-toggle onclick=toggleTheme() href></a>
<script src=https://pabdj.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Advanced Dynamic Techniques - WinDbg</h1><div class=meta>Posted on Mar 24, 2023</div></div><section class=body><h2 id=table-of-contents>Table of Contents</h2><ol><li><a href=#notes>Notes</a><ol><li><a href=#drivers-and-kernel-code>Drivers and Kernel Code</a></li><li><a href=#setting-up-kernel-debugging>Setting Up Kernel Debugging</a><ol><li><a href=#windows-xp-and-x86-architecture>Windows XP and x86 architecture</a></li><li><a href=#windows-vista-windows-7-and-x64-versions>Windows Vista, Windows 7, and x64 Versions</a></li></ol></li><li><a href=#using-windbg>Using WinDbg</a></li><li><a href=#microsoft-symbols>Microsoft Symbols</a></li><li><a href=#kernel-debugging-in-practice>Kernel Debugging in Practice</a><ol><li><a href=#user-space-code>User-space code</a></li><li><a href=#kernel-space-code>Kernel-space code</a></li></ol></li><li><a href=#loading-drivers>Loading Drivers</a></li></ol></li><li><a href=#labs>Labs</a><ol><li><a href=#lab-1>Lab 1</a></li><li><a href=#lab-2>Lab 2</a></li><li><a href=#lab-3>Lab 3</a></li></ol></li></ol><h2 id=notes>Notes</h2><h3 id=drivers-and-kernel-code>Drivers and Kernel Code</h3><p>Drivers must be loaded into the kernel, just as DLLs are loaded into processes. When a driver is first loaded, its <code>DriverEntry</code> procedure is called, similar to DLLMain for DLLs.
Unlike DLLs, which expose functionality through the export table, drivers must register the address for callback functions, which will be called when a user-space software component requests a service. The registration happens in the <code>DriverEntry</code> routine. Windows creates a <code>driver object</code> structure, which is passed to the <code>DriverEntry</code> routine. The <code>DriverEntry</code> routine is responsible for filling this structure in with its callback functions. The <code>DriverEntry</code> routine then creates a device that can be accessed from user space, and the user-space application interacts with the driver by sending requests to that device.</p><p>The most commonly encountered request for a malicious kernel component is <code>DeviceIoControl</code>, which is a generic request from a user-space module to a device managed by a driver. The user-space program passes an arbitrary length buffer of data as input and receives an arbitrary length buffer of data as output.</p><p>⚠️. <strong>Some kernel-mode malware has no significant user-mode component. It creates no device object, and the kernel-mode driver executes on its own.</strong></p><p>Malicious drivers generally do not usually control hardware; instead, they interact with the main Windows kernel components, <code>ntoskrnl.exe</code> and <code>hal.dll</code>. The <code>ntoskrnl.exe</code> component has the code for the core OS functions, and <code>hal.dll</code> has the code for interacting with the main hardware components.</p><h3 id=setting-up-kernel-debugging>Setting Up Kernel Debugging</h3><h4 id=windows-xp-and-x86-architecture>Windows XP and x86 architecture</h4><p>Before you start editing the boot.ini file, take a snapshot of your virtual machine. Then copy the last line of your boot.ini file and add another entry. The line should be the same except that you should add the options <code>/debug /debugport=COM1 /baudrate=115200</code>.</p><p>At VirtualBox, we have to configure the following settings:<figure><img src=../10-1-3.PNG></figure></p><p>And of course download <a href="https://apps.microsoft.com/store/detail/windbg-preview/9PGJGD53TN86?hl=es-es&amp;gl=es&amp;rtc=1">WinDbg Preview</a>.<figure><img src=../10-1-6.PNG></figure></p><h4 id=windows-vista-windows-7-and-x64-versions>Windows Vista, Windows 7, and x64 Versions</h4><p>One major change is that since Windows Vista, the boot.ini file is no longer used to determine which OS to boot. Vista and later versions of Windows use a program called BCDEdit to edit the boot configuration data.</p><p>PatchGuard, implemented in the x64 versions of Windows starting with Windows XP, prevents third-party code from modifying the kernel. This includes modifications to the kernel code itself, modifications to system service tables, modifications to the IDT, and other patching techniques.</p><p>If you attach a kernel debugger after booting up, PatchGuard will cause a system crash.</p><h3 id=using-windbg>Using WinDbg</h3><ul><li><strong>da</strong>. Reads from memory and displays it as ASCII text.</li><li><strong>du</strong>. Reads from memory and displays it as Unicode text.</li><li><strong>dd</strong>. Reads from memory and displays it as 32-bit double words.</li><li><strong>dwo</strong>. Dereferences a 32-bit pointer and see the value at that location, e.g. <code>du dwo (esp+4)</code></li><li><strong>bp</strong>. Sets basic breakpoints.</li></ul><h3 id=microsoft-symbols>Microsoft Symbols</h3><p>The format for referring to a symbol in WinDbg is as follows: <code>moduleName!symbolName</code></p><ul><li><em>ntoskrnl.exe</em> is a special case and the module name is <strong>nt</strong>, not <em>ntoskrnl</em>.</li></ul><p><code>bu newModule!exportedFunction</code> will instruct WinDbg to set a breakpoint on exportedFunction</p><ul><li>When analyzing kernel modules, the command <code>bu $iment(driverName)</code> will set a breakpoint on the entry point of a driver.</li></ul><p>The x command allows you to search for functions or symbols using wildcards.
<code>x nt!*CreateProcess*</code> will display exported functions as well as internal functions that include the string CreateProcess.</p><p><code>ln</code> command, which will list the closest symbol for a given memory address.</p><p><code>dt nt!_DRIVER_OBJECT ADDRESS</code> provides the driver object structure at that address, and it is useful to gather more information about it.</p><h3 id=kernel-debugging-in-practice>Kernel Debugging in Practice</h3><h4 id=user-space-code>User-space code</h4><ul><li><code>CreateService</code> function together with the parameter <code>dwService</code> containing <code>0x01</code> value, which indicates that this is a kernel driver.</li><li><code>DeviceIoControl</code> function to send data to the driver</li></ul><h4 id=kernel-space-code>Kernel-space code</h4><ul><li><code>!drvobj NameOfTheSuspiciousDriver</code></li><li>Sometimes the driver object will have a different name or !drvobj will fail. As an alternative, you can browse the driver objects with the !object \Driver command. This command lists all the objects in the \Driver namespace.</li><li><code>dt nt!_DRIVER_OBJECT ADDRESS</code></li><li>The <code>major function table</code> tells us what is executed when the malicious driver is called from user space. The table has different functions at each index. Each index represents a different type of request, and the indices are found in the file <em>wdm.h</em> and start with <code>IRP_MJ_</code>.</li><li><code>dd OBJECT_ADDRESS+OFFSET_MAJOR_FUNCTION+IRP_MJ_DEVICE_CONTROL_INDEX*4 L1</code> command finds the function that will be called to handle the DeviceIoControl request.</li><li><code>!devhandles</code> command obtains a list of all user-space applications that have a handle to that device. This command iterates through every handle table for every process, which takes a long time.</li></ul><h3 id=loading-drivers>Loading Drivers</h3><p>If you have a malicious driver, but no user-space application to install it, you can load the driver using a loader such as the <em>OSR Driver Loader</em> tool.</p><h2 id=labs>Labs</h2><h3 id=lab-1>Lab 1</h3><p><strong>1. Does this program make any direct changes to the registry? (Use procmon to check.)</strong></p><p>Before starting with dynamic analysis, we can observe the imports from the .exe file. They are listed In the following screenshot:<figure><img src=../10-1.PNG></figure></p><p>The exercise introduction tell us that in order for the program to work properly, the driver must be placed in the C:\Windows\System32 directory.
After placing the driver in the correct path and running the .exe file while capturing the events with <em>Procmon</em> we obtain the following capture:<figure><img src=../10-1-2.PNG></figure></p><p>As you can see, the only <strong>direct</strong> change made to the registry was the call that is pointed with the red arrow.</p><p><strong>2. The user-space program calls the ControlService function. Can you set a breakpoint with WinDbg to see what is executed in the kernel as a result of the call to ControlService?</strong></p><p><a href=https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-controlservice>ControlService function</a> sends a control code to a service.</p><p>In the following code snippet we can observe that the program creates and start a service. The fifth parameter (<em>dwService type</em>) is 0x01. This value indicates that this is a kernel driver.<figure><img src=../10-1-4.PNG></figure></p><p>This function is located at 0x00401080 as it can be seen in the image below.<figure><img src=../10-1-5.PNG></figure></p><p>We can set a breakpoint with OllyDbg and then observe any changes in WinDbg.<figure><img src=../10-1-7.PNG></figure></p><p>For example, after running the .exe file in OllyDbg and stopping the execution, we break and run the following command in WinDbg: <code>!drvobj Lab10-01</code><figure><img src=../10-1-8.PNG></figure></p><p>This indicates that the Driver has been loaded into 0x8996EC08. If we search for more information at that location with <code>dt nt!_DRIVER_OBJECT 8996ec08</code>, we observe the following:<figure><img src=../10-1-9.PNG></figure></p><p>As we want to know what is happening before the driver is unloaded we set a breakpoint at 0xF7A77486 with the command <code>bp 0xF7A77486</code>. Then, we resume the file in OllyDbg and the breakpoint is inmediately hit. With <code>x nt!*CreateRegistryKey*</code> we will display exported functions as well as internal functions that include the string CreateRegistryKey.<figure><img src=../10-1-10.png></figure></p><p>With <em>ln</em> command we can browse to that memory address and then observe the different operations that are performed.<figure><img src=../10-1-11.PNG></figure></p><p>If we analyse further the driver in Ghidra we can see that it is modifying registry keys related to Windows Firewall, particularly setting its value to 0.<figure><img src=../10-1-12.PNG></figure><figure><img src=../10-1-13.PNG></figure></p><p><strong>3. What does this program do?</strong></p><p>The program loads a driver that disables Windows Firewall.</p><h3 id=lab-2>Lab 2</h3><p><strong>1. Does this program create any files? If so, what are they?</strong></p><p>First of all we have to look at the imports and strings with FLOSS. This is the information that we have retrieved with basic static analysis:</p><table><thead><tr><th style=text-align:center>Imports</th><th style=text-align:center>Strings</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../10-2.PNG></figure></td><td style=text-align:center><figure><img src=../10-2-1.PNG></figure></td></tr></tbody></table><p>If we run this sample together with Procmon we can observe that it creates a driver filled called &ldquo;<em>Mlwx486.sys</em>&rdquo;<figure><img src=../10-2-2.PNG></figure></p><p>This information can also be obtained by loading the file into Ghidra and looking at the main function. The file &ldquo;<em>Lab10-02.exe</em>&rdquo; has another file attached to itself in the resource section. It creates the driver file &ldquo;<em>Mlwx486.sys</em>&rdquo; and loads the resource into that file.<figure><img src=../10-2-3.PNG></figure></p><p><strong>2. Does this program have a kernel component?</strong></p><p>The program creates and start a service. The fifth parameter (<em>dwService type</em>) is 0x01. This value indicates that this is a kernel driver.</p><p><strong>3. What does this program do?</strong></p><p>The file &ldquo;<em>Lab10-02.exe</em>&rdquo; has another file attached to itself in the resource section. It creates the driver file &ldquo;<em>Mlwx486.sys</em>&rdquo; and loads the resource into that file.</p><p>With ResourceHacker we are able to save that file and analyze it to obtain the functionality of the driver.<figure><img src=../10-2-4.PNG></figure></p><p>The first line in the picture above mentions the word <strong>rootkit</strong>. Hint?
Part of the chapter is dedicated to them, and it mentions the following:
<code>Although rootkits can employ a diverse array of techniques, in practice, one technique is used more than any other: System Service Descriptor Table (SSDT) hooking.</code>
It also says that if <em>NtQueryDirectoryFile</em>, among others functions, is hooked, it will change the value in the SSDT so that the rootkit code is called instead of the intended function in the kernel.</p><p>This can be confirmed by examining the driver file in Ghidra.<figure><img src=../10-2-5.PNG></figure></p><h3 id=lab-3>Lab 3</h3><p><strong>1. What does this program do?</strong></p><p>Firstly, we need to look at the imports and strings with FLOSS.</p><table><thead><tr><th style=text-align:center>Imports</th><th style=text-align:center>Strings</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../10-3.PNG></figure></td><td style=text-align:center><figure><img src=../10-3-1.PNG></figure></td></tr></tbody></table><p>With dynamic analysis we have retrieved useful information. As you can observe in the following pictures, the malware sample queries the URL &ldquo;www[.]malwareanalysisbook[.]com&rdquo;.<figure><img src=../10-3-4.PNG></figure></p><p>If we take a look at this screenshot, we can see that requests to the malicious URL are made every 30 seconds.<figure><img src=../10-3-3.PNG></figure><figure><img src=../10-3-5.PNG></figure></p><p>On the other hand, with Procmon we have not acquired any indicator that shows registry or file creation and modification.</p><p>If we import the malware to Ghidra we can get more information about the sample. Lines 38 to 40 show an infinite loop that every 30 seconds queries the URL, as we mentioned before.
At the beginning of the main function, we can see that a service is created and started. Next, a file is created, although this operation is not captured by Procmon.<figure><img src=../10-3-2.PNG></figure></p><p>Regarding the .sys file, the following images shows its strings and entry function:</p><table><thead><tr><th style=text-align:center>Strings</th><th style=text-align:center>Entry function</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../10-3-6.PNG></figure></td><td style=text-align:center><figure><img src=../10-3-7.PNG></figure></td></tr></tbody></table><p><strong>2. Once this program is running, how do you stop it?</strong></p><p>We can either reboot the machine or exit the Internet Explorer process.</p><p><strong>3. What does the kernel component do?</strong></p><p>Recalling basic dynamic analysis, the process did not appear in the Process List. This is achieved thanks to the driver, as it hides the process by unlinking it from the user processes.</p></section><div class=post-tags><nav class="nav tags"><h2 class=title>Tags</h2><ul class=tags><li><a href=/tags/practical-malware-analysis>practical malware analysis</a></li><li><a href=/tags/malware>malware</a></li><li><a href=/tags/reversing>reversing</a></li><li><a href=/tags/advanced>advanced</a></li><li><a href=/tags/dynamic>dynamic</a></li><li><a href=/tags/analysis>analysis</a></li><li><a href=/tags/x86>x86</a></li><li><a href=/tags/x64>x64</a></li><li><a href=/tags/assembly>assembly</a></li><li><a href=/tags/registers>registers</a></li><li><a href=/tags/windbg>windbg</a></li><li><a href=/tags/ghidra>ghidra</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/pabdj title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/pabdjf title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=https://es.linkedin.com/in/pablodejuanfidalgo title=LinkedIn><i data-feather=linkedin></i></a>
<a class=border></a></div><div class=footer-info>2023 © Pablo de Juan Fidalgo |</div></footer><script>feather.replace()</script></div></body></html>