<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Advanced Static Techniques - Analyzing Malicious Windows Programs - Pablo de Juan Fidalgo</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Table of Contents Notes Windows API types Windows Registry Registry Root Keys Networking APIs Following running malware Kernel vs. User Mode The Native API Labs Lab 1 Lab 2 Lab 3 Notes DWORD and WORD types represent 32-bit and 16-bit unsigned integers. Windows does not use int, short or unsigned. Windows API types Handles (H). A reference to an object. Long Pointer (LP). A pointer to another type. CreateFile. This function is used to create and open files."><meta property="og:image" content><meta property="og:title" content="Advanced Static Techniques - Analyzing Malicious Windows Programs"><meta property="og:description" content="Table of Contents Notes Windows API types Windows Registry Registry Root Keys Networking APIs Following running malware Kernel vs. User Mode The Native API Labs Lab 1 Lab 2 Lab 3 Notes DWORD and WORD types represent 32-bit and 16-bit unsigned integers. Windows does not use int, short or unsigned. Windows API types Handles (H). A reference to an object. Long Pointer (LP). A pointer to another type. CreateFile. This function is used to create and open files."><meta property="og:type" content="article"><meta property="og:url" content="https://pabdj.github.io/posts/advancedstatictechniques_analyzing_malicious_windows_programs/advancedstatictechniques_analyzingmaliciouswindowsprograms/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-26T14:25:58+05:30"><meta property="article:modified_time" content="2022-12-26T14:25:58+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advanced Static Techniques - Analyzing Malicious Windows Programs"><meta name=twitter:description content="Table of Contents Notes Windows API types Windows Registry Registry Root Keys Networking APIs Following running malware Kernel vs. User Mode The Native API Labs Lab 1 Lab 2 Lab 3 Notes DWORD and WORD types represent 32-bit and 16-bit unsigned integers. Windows does not use int, short or unsigned. Windows API types Handles (H). A reference to an object. Long Pointer (LP). A pointer to another type. CreateFile. This function is used to create and open files."><script src=https://pabdj.github.io/js/feather.min.js></script>
<link href=https://pabdj.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://pabdj.github.io/css/main.0fd5f05032e8d6d12808eb2d48a5a295f4ee5cd8eefd5bf3dbfd49a346d206ed.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://pabdj.github.io/css/dark.73617b6be66d271725422ddf83ec3f8c57af298005233c552735d43adf634f04.css disabled></head><body><div class=content><header><div class=main><a href=https://pabdj.github.io/>Pablo de Juan Fidalgo</a></div><nav><a href=/>Home</a>
<a href=/posts>Blog</a>
<a href=/tags>Tags</a>
| <a id=dark-mode-toggle onclick=toggleTheme() href></a>
<script src=https://pabdj.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Advanced Static Techniques - Analyzing Malicious Windows Programs</h1><div class=meta>Posted on Dec 26, 2022</div></div><section class=body><h2 id=table-of-contents>Table of Contents</h2><ol><li><a href=#notes>Notes</a><ol><li><a href=#windows-api-types>Windows API types</a></li><li><a href=#windows-registry>Windows Registry</a><ol><li><a href=#registry-root-keys>Registry Root Keys</a></li></ol></li><li><a href=#networking-apis>Networking APIs</a></li><li><a href=#following-running-malware>Following running malware</a></li><li><a href=#kernel-vs-user-mode>Kernel vs. User Mode</a></li><li><a href=#the-native-api>The Native API</a></li></ol></li><li><a href=#labs>Labs</a><ol><li><a href=#lab-1>Lab 1</a></li><li><a href=#lab-2>Lab 2</a></li><li><a href=#lab-3>Lab 3</a></li></ol></li></ol><h2 id=notes>Notes</h2><ul><li>DWORD and WORD types represent 32-bit and 16-bit unsigned integers. Windows does not use int, short or unsigned.</li></ul><h3 id=windows-api-types>Windows API types</h3><ul><li><strong>Handles (H)</strong>. A reference to an object.</li><li><strong>Long Pointer (LP)</strong>. A pointer to another type.</li><li><strong>CreateFile</strong>. This function is used to create and open files. The parameter <em>dwCreationDisposition</em> controls whether the CreateFile function creates a new file or opens an existing one.</li><li><strong>CreateFileMapping</strong> and <strong>MapViewOfFile</strong>. File mappings are commonly used by malware writers because they allow a file to be loaded into memory and manipulated easily. The CreateFileMapping function loads a file from disk into memory. After obtaining a map of the file, the malware can parse the PE header and make all necessary changes to the file in memory, thereby causing the PE file to be executed as if it had been loaded by the OS loader.</li><li><strong>Shared Files</strong>. Shared files are special files with names that start with \serverName\share or \?\serverName\share. They access directories or files in a shared folder stored on a network.</li><li><strong>Files Accessible via Namespaces</strong>. Additional files are accessible via namespaces within the OS. It allows to directly access physical devices while ignoring its file system, thereby allowing it to modify the disk in ways that are not possible through the normal API. Using this method, the malware might be able to read and write data to an unallocated sector without creating or accessing files, which allows it to avoid detection by antivirus and security programs.</li><li><strong>Alternate Data Streams</strong>. It allows additional data to be added to an existing file within NTFS, essentially adding one file to another. The extra data does not show up in a directory listing, and it is not shown when displaying the contents of the file; it’s visible only when you access the stream.</li></ul><h3 id=windows-registry>Windows Registry</h3><h4 id=registry-root-keys>Registry Root Keys</h4><p>The registry is split into the following five root keys:</p><ul><li><strong>HKEY_LOCAL_MACHINE (HKLM)</strong>.</li><li><strong>HKEY_CURRENT_USER (HKCU)</strong>.</li><li><strong>HKEY_CLASSES_ROOT</strong>.</li><li><strong>HKEY_CURRENT_CONFIG</strong>.</li><li><strong>HKEY_USERS</strong>.</li></ul><h4 id=common-registry-functions>Common Registry Functions</h4><p>The following are the most common registry functions that malware uses:</p><ul><li><strong>RegOpenKeyEx</strong>.</li><li><strong>RegSetValueEx</strong>.</li><li><strong>RegGetValue</strong>.</li></ul><h3 id=networking-apis>Networking APIs</h3><p>The <em><strong>WSAStartup</strong></em> function must be called before any other networking functions in order to allocate resources for the networking libraries. When looking for the start of network connections while debugging code, it is useful to <strong>set a breakpoint on <em>WSAStartup</em></strong>, because the start of networking should follow shortly.</p><p>The <em><strong>WinINet API</strong></em> implements protocols, such as HTTP and FTP, at the application layer.</p><h3 id=following-running-malware>Following running malware</h3><p>Malware can use <em><strong>CreateThread</strong></em> in multiple ways, such as the following:</p><ul><li>Malware can use <em><strong>CreateThread</strong></em> to load a new malicious library into a process, with <em><strong>CreateThread</strong></em> called and the address of <em><strong>LoadLibrary</strong></em> specified as the start address. (The argument passed to <em><strong>CreateThread</strong></em> is the name of the library to be loaded. The new DLL is loaded into memory in the process, and <em><strong>DllMain</strong></em> is called.)</li><li>Malware can create two new threads for input and output: one to listen on a socket or pipe and then output that to standard input of a process, and the other to read from standard output and send that to a socket or pipe. The malware’s goal is to send all information to a single socket or pipe in order to communicate seamlessly with the running application.</li></ul><p>In addition to threads, Microsoft systems use <em><strong>fibers</strong></em>. Fibers are like threads, but are managed by a thread, rather than by the OS. Fibers share a single thread context.</p><p>Another way for malware to execute additional code is by installing it as a service. Windows allows tasks to run without their own processes or threads by using services that run as background applications; code is scheduled and run by the Windows service manager without user input.
There are several key functions to look for:</p><ul><li><strong>OpenSCManager</strong>.</li><li><strong>CreateService</strong>.</li><li><strong>StartService</strong>.</li></ul><p>The Windows OS supports several service types, which execute in unique ways. The one most commonly used by malware is the <em><strong>WIN32_SHARE_PROCESS</strong></em> type, which stores the code for the service in a DLL, and combines several services in a single, shared process. The <em><strong>WIN32_OWN_PROCESS</strong></em> type and<em><strong>KERNEL_DRIVER</strong></em> type are also used.
The <em>qc</em> command queries a service’s configuration options by accessing the same information as the registry entry in a more readable way.</p><p><code>C:\Users\User1>sc qc "VMware NAT Service"</code></p><p>Each thread that uses COM must call the <em><strong>OleInitialize</strong></em> or <em><strong>CoInitializeEx</strong></em> function at least once prior to calling any other COM library functions. The <em><strong>CoCreateInstance</strong></em> function is used to get access to COM functionality.</p><ul><li>One common function used by malware is <em><strong>Navigate</strong></em>, which allows a program to launch Internet Explorer and access a web address.
In order to identify what a malicious program is doing when it calls a COM function, malware analysts must determine which offset a function is stored at, which can be tricky. IDA Pro stores the offsets and structures for common interfaces, which can be explored via the structure subview. Press the <em>INSERT</em> key to add a structure, and then click <strong>Add Standard Structure</strong>. The name of the structure to add is <em><strong>InterfaceNameVtbl</strong></em>.
Malware that implements a COM server is usually easy to detect because it exports several functions, including <em><strong>DllCanUnloadNow</strong></em>, <em><strong>DllGetClassObject</strong></em>, <em><strong>DllInstall</strong></em>, <em><strong>DllRegisterServer</strong></em>, and <em><strong>DllUnregisterServer</strong></em>, which all must be exported by COM servers.</li></ul><p><em>Structured Exception Handling</em> (SEH) is the Windows mechanism for handling exceptions. In 32-bit systems, SEH information is stored on the <strong>stack</strong>. The special location <em><strong>fs:0</strong></em> points to an address on the stack that stores the exception information.</p><h3 id=kernel-vs-user-mode>Kernel vs. User Mode</h3><p>When you call a Windows API function that manipulates kernel structures, it will make a call into the kernel. The presence of the <em>SYSENTER</em>, <em>SYSCALL</em>, or <em>INT 0x2E</em> instruction in disassembly indicates that a call is being made into the kernel.</p><h3 id=the-native-api>The Native API</h3><p>The Native API is a lower-level interface for interacting with Windows that is rarely used by non-malicious programs but is popular among malware writers.
User applications are given access to user APIs such as <em>kernel32.dll</em> and other DLLs, which call <em>ntdll.dll</em>, a special DLL that manages interactions between user space and the kernel. The processor then switches to kernel mode and executes a function in the kernel, normally located in <em>ntoskrnl.exe</em>.
There are a series of Native API calls that can be used to get information about the system, processes, threads, handles, and other items. These include <em><strong>NtQuerySystemInformation</strong></em>, <em><strong>NtQueryInformationProcess</strong></em>, <em><strong>NtQueryInformationThread</strong></em>, <em><strong>NtQueryInformationFile</strong></em>, <em><strong>NtQueryInformationKey</strong></em> and <em><strong>NtContinue</strong></em>.</p><h2 id=labs>Labs</h2><h3 id=lab-1>Lab 1</h3><p><strong>1. How does this program ensure that it continues running (achieves persistence) when the computer is restarted?</strong></p><p>Before going that deep on how the malware achieves persistence we have to perform a basic static and dynamic analysis.</p><p>Regarding the imports we can observe that it calls <em>InternetOpenA</em> and <em>InternetOpenUrlA</em> for networking capabilities. It also imports some service functions such as <em>OpenSCManagerA</em> and <em>CreateServiceA</em>. Last but not least, it imports functions such as <em>CreateThread</em>, <em>CreateMutex</em>, <em>OpenMutex</em> and <em>GetStartupInfo</em> among others.</p><p>Inside the strings we see things like &ldquo;<em>MalService</em>&rdquo;, &ldquo;<em>hxxp://www[.]malwareanalysisbook[.]com</em>&rdquo;, or &ldquo;<em>Internet Explorer 8.0</em>&rdquo;.</p><p>Now, let&rsquo;s get a better overview of the malware with a basic dynamic analysis.
With the following screenshots we have gathered a lot of information.</p><p>👉 Wireshark<figure><img src=../7-1.PNG></figure></p><p>👉 Regshot<figure><img src=../7-1-1.PNG></figure></p><p>👉 ProcessExplorer<figure><img src=../7-1-2.PNG></figure></p><p>Looking at Regshot screenshot we observe that the sample adds new keys to the registry with the name &ldquo;<em>Malservice</em>&rdquo;.</p><p><strong>2. Why does this program use a mutex?</strong></p><p>It checks if the victim machine is already infected by checking if it contains an entry to the malicious URL in the history.</p><p><strong>3. What is a good host-based signature to use for detecting this program?</strong></p><p>The service &ldquo;<em>Malservice</em>&rdquo; and the mutex &ldquo;<em>HGL345</em>&rdquo; are good host-based signature.</p><p><strong>4. What is a good network-based signature for detecting this malware?</strong></p><p>The URL &ldquo;<em>hxxp://www[.]malwareanalysisbook[.]com</em>&rdquo; and the User-Agent &ldquo;<em>Internet Explorer 8.0</em>&rdquo;.</p><p><strong>5. What is the purpose of this program?</strong></p><p>First of all we land into main.<figure><img src=../7-1-3.PNG></figure></p><p>From there, we jump into subroutine located at 0x401040.<figure><img src=../7-1-4.PNG></figure></p><p>A timer is set to start on January 1st, 2100 and 20 threads are created which perform the following actions.<figure><img src=../7-1-5.PNG></figure></p><p>An infinite loop is done in order to perform a great amount of requests to the URL. That means that a Denial of Service (DoS) attack is created.</p><p><strong>6. When will this program finish executing?</strong></p><p>The program will never end as the threads are continuously executing.</p><h3 id=lab-2>Lab 2</h3><p><strong>1. How does this program achieve persistence?</strong></p><p>The program calls <em>OleInitialize</em> function and after that it gets access to COM functionality with <em>CoCreateInstance</em> function.<figure><img src=../7-2.PNG></figure></p><p>In order to get more information we need to gather information related to the parameters that <em>CoCreateInstance</em> function receives. IDA displays the information more beautiful in comparison with Ghidra.</p><table><thead><tr><th style=text-align:center>Ghidra</th><th style=text-align:center>IDA Free v8.1</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../7-2-1.PNG></figure></td><td style=text-align:center><figure><img src=../7-2-2.PNG></figure></td></tr></tbody></table><p>The CLSID value is &ldquo;{0002DF01-0000-0000-C000-000000000046}&rdquo; so the next step is to search for it in the Windows Registry.<figure><img src=../7-2-3.PNG></figure></p><p>The malware sample is making an instance of the Internet Explorer object and if we take a look at the disassembly previously shown, in line 22 we can it calls the object with an offset equals to 0x2C which looks familiar.
In this Chapter, it was mentioned that function 0x2C is <em>Navigate</em> function.</p><p>I tried to find this by myself, but I struggled through the process. Along the way I found this post from Mandiant.</p><ul><li><a href=https://www.mandiant.com/resources/blog/reversing-malware-command-control-sockets>Reversing Malware Command and Control: From Sockets to COM</a></li></ul><p><code>This function is at offset 2Ch from the beginning of the ppv data structure, and you can tell that the binary is calling this function because the call instruction accesses this specific offset from the beginning of the structure ("call dword ptr [ecx+**2Ch**]"). There is no clear-cut way to go directly from the Microsoft documentation of this COM interface to seeing the actually internal offset used by each member function [...]</code></p><p>Anyway, as we can observe, there is no sign of persistence in the code.</p><p><strong>2. What is the purpose of this program?</strong></p><p>It browses to a malicious URL &ldquo;<em>hxxp://www[.]malwareanalysisbook[.]com/ad.html</em>&rdquo;.</p><p><strong>3. When will this program finish executing?</strong></p><p>It will finish after making the request to the malicious URL.</p><h3 id=lab-3>Lab 3</h3><p><strong>1. How does this program achieve persistence to ensure that it continues running when the computer is restarted?</strong></p><p>The first thing is running strings in order to have a first contact with the sample. This way we can observe the imports and possible IoCs.</p><table><thead><tr><th style=text-align:center>.exe file</th><th style=text-align:center>.dll file</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../7-3.PNG></figure></td><td style=text-align:center><figure><img src=../7-3-1.PNG></figure></td></tr></tbody></table><p>The .exe file deals with file management functions such as <em>CreateFile</em>, <em>CopyFile</em> or <em>FindNextFile</em>. An important feature of this file is that it plays with the similarity of number &ldquo;1&rdquo; and lowercase letter &ldquo;L&rdquo;. It might be used for stealthiness.</p><p>Regarding the .dll file it works with mutex functions and a suspicious IP address appears &ldquo;127[.]26[.]152[.]13&rdquo;.</p><p>Unfortunately, when performing a basic dynamic analysis nothing valuable is found. The last resource we have is disassembling the file with Ghidra.</p><figure><img src=../7-3-2.PNG></figure><p>From the screenshot above we can observe that the program calls <em>CreateFileMapping</em> function that loads a file from disk into memory. The <em>MapViewOfFile</em> function returns a pointer to the base address of the mapping, which can be used to access the file in memory. The program calling these functions can use the pointer returned from <em>MapViewOfFile</em> to read and write anywhere in the file.</p><table><thead><tr><th style=text-align:center>First part of the code</th><th style=text-align:center>End of the code</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../7-3-3.PNG></figure></td><td style=text-align:center><figure><img src=../7-3-4.PNG></figure></td></tr></tbody></table><p>The way of achieving persistence is by substituting one file by another with similar names.</p><p><strong>2. What are two good host-based signatures for this malware?</strong></p><p>File &ldquo;<em>kerne132.dll</em>&rdquo; and mutex &ldquo;<em>SADFHUHF</em>&rdquo;.</p><figure><img src=../7-3-5.PNG></figure><p><strong>3. What is the purpose of this program?</strong></p><p>The .exe file installs the .dll file in the system, which is used for connecting to an IP address and establishing a remote connection with a server.</p><figure><img src=../7-3-6.PNG></figure><table><thead><tr><th style=text-align:center><em>hello</em> command</th><th style=text-align:center><em>sleep</em> and <em>exec</em> commands</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../7-3-7.PNG></figure></td><td style=text-align:center><figure><img src=../7-3-8.PNG></figure></td></tr></tbody></table><p>In order to end the connection there is a q(uit) command.</p><p><strong>4. How could you remove this malware once it is installed?</strong></p><p>Something that I missed while analyzing the sample is that it infects <strong>all</strong> .exe files in the system. In our case the best option to remove the malware is by restoring the snapshot that we have. In a non-lab machine we would have to restore kernel32.dll in the place of <em>kernel132.dll</em>.</p></section><div class=post-tags><nav class="nav tags"><h2 class=title>Tags</h2><ul class=tags><li><a href=/tags/practical-malware-analysis>practical malware analysis</a></li><li><a href=/tags/malware>malware</a></li><li><a href=/tags/reversing>reversing</a></li><li><a href=/tags/advanced>advanced</a></li><li><a href=/tags/static>static</a></li><li><a href=/tags/analysis>analysis</a></li><li><a href=/tags/x86>x86</a></li><li><a href=/tags/x64>x64</a></li><li><a href=/tags/assembly>assembly</a></li><li><a href=/tags/registers>registers</a></li><li><a href=/tags/ida>ida</a></li><li><a href=/tags/ghidra>ghidra</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/pabdj title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/pabdjf title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=https://es.linkedin.com/in/pablodejuanfidalgo title=LinkedIn><i data-feather=linkedin></i></a>
<a class=border></a></div><div class=footer-info>2023 © Pablo de Juan Fidalgo |</div></footer><script>feather.replace()</script></div></body></html>