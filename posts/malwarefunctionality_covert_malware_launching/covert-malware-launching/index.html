<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Malware Functionality - Covert Malware Launching - Pablo de Juan Fidalgo</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Table of Contents Notes Launchers Process Injection DLL injection Direct injection Process Replacement Hook Injection Keyloggers Using SetWindowsHookEx Detours APC Injection From User Space From Kernel Space Labs Lab 1 Lab 2 Lab 3 Lab 4 Notes Launchers Type of malware that sets itself or another piece of malware for immediate or future covert execution. Launchers will often store malware within the resource section. When the launcher is run, it extracts an embedded executable or DLL from the resource section before launching it."><meta property="og:image" content><meta property="og:title" content="Malware Functionality - Covert Malware Launching"><meta property="og:description" content="Table of Contents Notes Launchers Process Injection DLL injection Direct injection Process Replacement Hook Injection Keyloggers Using SetWindowsHookEx Detours APC Injection From User Space From Kernel Space Labs Lab 1 Lab 2 Lab 3 Lab 4 Notes Launchers Type of malware that sets itself or another piece of malware for immediate or future covert execution. Launchers will often store malware within the resource section. When the launcher is run, it extracts an embedded executable or DLL from the resource section before launching it."><meta property="og:type" content="article"><meta property="og:url" content="https://pabdj.github.io/posts/malwarefunctionality_covert_malware_launching/covert-malware-launching/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-01T15:00:58+05:30"><meta property="article:modified_time" content="2023-04-01T15:00:58+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Malware Functionality - Covert Malware Launching"><meta name=twitter:description content="Table of Contents Notes Launchers Process Injection DLL injection Direct injection Process Replacement Hook Injection Keyloggers Using SetWindowsHookEx Detours APC Injection From User Space From Kernel Space Labs Lab 1 Lab 2 Lab 3 Lab 4 Notes Launchers Type of malware that sets itself or another piece of malware for immediate or future covert execution. Launchers will often store malware within the resource section. When the launcher is run, it extracts an embedded executable or DLL from the resource section before launching it."><script src=https://pabdj.github.io/js/feather.min.js></script>
<link href=https://pabdj.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://pabdj.github.io/css/main.0fd5f05032e8d6d12808eb2d48a5a295f4ee5cd8eefd5bf3dbfd49a346d206ed.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://pabdj.github.io/css/dark.73617b6be66d271725422ddf83ec3f8c57af298005233c552735d43adf634f04.css disabled></head><body><div class=content><header><div class=main><a href=https://pabdj.github.io/>Pablo de Juan Fidalgo</a></div><nav><a href=/>Home</a>
<a href=/posts>Blog</a>
<a href=/tags>Tags</a>
| <a id=dark-mode-toggle onclick=toggleTheme() href></a>
<script src=https://pabdj.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Malware Functionality - Covert Malware Launching</h1><div class=meta>Posted on Apr 1, 2023</div></div><section class=body><h2 id=table-of-contents>Table of Contents</h2><ol><li><a href=#notes>Notes</a><ol><li><a href=#launchers>Launchers</a></li><li><a href=#process-injection>Process Injection</a><ol><li><a href=#dll-injection>DLL injection</a></li></ol></li><li><a href=#direct-injection>Direct injection</a></li><li><a href=#process-replacement>Process Replacement</a></li><li><a href=#hook-injection>Hook Injection</a><ol><li><a href=#keyloggers>Keyloggers</a></li><li><a href=#using-setwindowshookex>Using SetWindowsHookEx</a></li></ol></li><li><a href=#detours>Detours</a></li><li><a href=#apc-injection>APC Injection</a><ol><li><a href=#from-user-space>From User Space</a></li><li><a href=#from-kernel-space>From Kernel Space</a></li></ol></li></ol></li><li><a href=#labs>Labs</a><ol><li><a href=#lab-1>Lab 1</a></li><li><a href=#lab-2>Lab 2</a></li><li><a href=#lab-3>Lab 3</a></li><li><a href=#lab-4>Lab 4</a></li></ol></li></ol><h2 id=notes>Notes</h2><h3 id=launchers>Launchers</h3><p>Type of malware that sets itself or another piece of malware for immediate or future covert execution. Launchers will often store malware within the resource section. When the launcher is
run, it extracts an embedded executable or DLL from the resource section before launching it.</p><h3 id=process-injection>Process Injection</h3><p>This technique injects code into another running process, and that process unwittingly executes the malicious code. There are some functions linked to this technique, such as <em>VirtualAllocEx</em> function, that can be used to allocate space in an external process’s memory, and <em>WriteProcessMemory</em> that can be used to write data to that allocated space.</p><h4 id=dll-injection>DLL injection</h4><p>It is a form of process injection where a remote process is forced to load a malicious DLL, and it is the most commonly used covert loading technique.
DLL injection works by injecting code into a remote process that calls <em>LoadLibrary</em>, thereby forcing a DLL to be loaded in the context of that process.</p><p>The typical pattern is as follows:</p><ul><li><em>CreateToolhelp32Snapshot</em>, <em>Process32First</em>, and <em>Process32Next</em> to search the process list for the injection target.</li><li>Retrieve the process identifier (PID) and obtain the handle via a call to <em>OpenProcess</em>.</li><li><em>VirtualAllocEx</em> and <em>WriteProcessMemory</em>.</li><li><em>CreateRemoteThread</em> with these parameters: the process handle (<em>hProcess</em>) obtained with <em>OpenProcess</em>, along with the starting point of the injected thread (<em>lpStartAddress</em>) and an argument for that thread (<em>lpParameter</em>).</li></ul><h3 id=direct-injection>Direct injection</h3><p>It uses many of the same Windows API calls as DLL injection. The difference is that instead
of writing a separate DLL and forcing the remote process to load it, direct injection malware injects the malicious code directly into the remote process. It is more flexible than DLL injection, but it requires a lot of customized code in order to run successfully without negatively impacting
the host process. This technique can be used to inject compiled code, <strong>but more often, it’s used to inject shellcode</strong>.</p><h3 id=process-replacement>Process Replacement</h3><p>It overwrites the memory space of a running process with a malicious executable instead of inject code into a host program. Key to process replacement is creating a process in a <strong>suspended state</strong> (by passing <code>CREATE_SUSPENDED (0x4)</code> as the <em>dwCreationFlags</em> parameter when performing
the call to <em>CreateProcess</em>). This means that the process will be loaded into memory, but the primary thread of the process is suspended. Once the process is created, the next step is to replace the victim process’s memory with the malicious executable, typically using <em>ZwUnmapViewOfSection</em>.</p><h3 id=hook-injection>Hook Injection</h3><p>There are two types of Windows hooks:</p><ul><li>Local hooks are used to observe or manipulate messages destined for an internal process.</li><li>Remote hooks are used to observe or manipulate messages destined for a remote process (another process on the system).<ul><li>High-level remote hooks. They require that the hook procedure be an exported function contained in a DLL.</li><li>Low-level remote hooks require that the hook procedure be contained in the process that installed the hook.</li></ul></li></ul><h4 id=keyloggers>Keyloggers</h4><p>Hook injection is frequently used in malicious applications known as keyloggers, which record keystrokes. Keystrokes can be captured by registering high- or low-level hooks using the <em>WH_KEYBOARD</em> or <em>WH_KEYBOARD_LL</em> hook procedure types, respectively.</p><h4 id=using-setwindowshookex>Using SetWindowsHookEx</h4><p>The principal function call used to perform remote Windows hooking is <em>SetWindowsHookEx</em>, which has the following parameters:</p><ul><li><em>idHook</em>. Specifies the type of hook procedure to install.</li><li><em>lpfn</em>. Points to the hook procedure.</li><li><em>hMod</em>. For high-level hooks, identifies the handle to the DLL containing the hook procedure defined by lpfn. For low-level hooks, this identifies the local module in which the lpfn procedure is defined.</li><li><em>dwThreadId</em>. Specifies the identifier of the thread with which the hook procedure is to be associated. If this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread (tipically only a single thread will be injected in order to remain stealthy). This must be set to zero for low-level hooks.</li></ul><p>The hook procedure can contain code to process messages as they come in from the system, or it can do nothing. Either way, the hook procedure must call <em>CallNextHookEx</em>.</p><h3 id=detours>Detours</h3><p>Malware authors most commonly use Detours to add new DLLs to existing binaries on disk. The malware modifies the PE structure and creates a section named <em>.detour</em>, which is typically placed between the export table and any debug symbols. The .detour section contains the original PE header with a new import address table. The malware author then uses Detours to modify the PE header to point to the new import table, by using the <em>setdll</em> tool provided with the Detours library.</p><h3 id=apc-injection>APC Injection</h3><p>Instead of creating a thread, APCs (asynchronous procedure call) can direct a thread to execute some other code prior to executing its regular execution path. Whenever the thread calls functions like <em>WaitForSingleObjectEx</em>, <em>WaitForMultipleObjectsEx</em>, and <em>Sleep</em>, it can process the APCs.</p><h4 id=from-user-space>From User Space</h4><p>From user space, another thread can queue a function to be invoked in a remote thread, using the API function <em>QueueUserAPC</em>. Because a thread must be in an alertable state in order to run a user-mode APC, malware will look to target threads in processes that are likely to go into that state.</p><h4 id=from-kernel-space>From Kernel Space</h4><p>A malicious driver can build an APC and dispatch a thread to execute it in a user-mode process (most often svchost.exe). APCs of this type often consist of <strong>shellcode,</strong> and they make use of these two functions <em>KeInitializeApc</em> (if <em>NormalRoutine</em> parameter is non-zero in combination with the parameter ApcMode being set to 1, then we are looking at an usermode type) and <em>KeInsertQueueApc</em>.</p><h2 id=labs>Labs</h2><h3 id=lab-1>Lab 1</h3><p><strong>1. What happens when you run the malware executable?</strong></p><p>First of all, we retrieve the strings and imports from both files with FLOSS.</p><table><thead><tr><th style=text-align:center>Lab12-01.exe</th><th style=text-align:center>Lab12-01.dll</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../12-1.PNG></figure></td><td style=text-align:center><figure><img src=../12-1-2.PNG></figure></td></tr></tbody></table><p>If we run the program, we will observe that the following pop-up windows appears again and again after a short period of time.<figure><img src=../12-1-4.PNG></figure></p><p><strong>2. What process is being injected?</strong></p><p>The following image shows the function call graph. As we can observe, it is clear that we are dealing with DLL injection, due to the pattern &ldquo;<em>OpenProcess</em>, <em>VirtualAllocEx</em>, <em>WriteProcessMemory</em> and <em>CreateRemoteThread</em>&rdquo;.<figure><img src=../12-1-6.PNG></figure></p><p>There are two calls to <em>OpenProcess</em>, but we will take a look at the first one, located at 0x40104B.<figure><img src=../12-1-7.PNG></figure></p><p>We can see that it is inside a subroutine, and it checks if the process is <em>explorer.exe</em>.<figure><img src=../12-1-8.PNG></figure></p><p><strong>3. How can you make the malware stop the pop-ups?</strong></p><p>We can kill the thread in the process explorer.exe.<figure><img src=../12-1-10.PNG></figure>]</p><p><strong>4. How does this malware operate?</strong></p><p>It takes the process list, and it searches for <em>explorer.exe</em>. Once it is located, a typical process injection is performed, injecting <em>Lab12-01.dll</em> and creating a new thread that pop-ups a message every minute.<figure><img src=../12-1-9.PNG></figure></p><h3 id=lab-2>Lab 2</h3><p><strong>1. What is the purpose of this program?</strong></p><p>Taking a look at the imports, we can observe some suspicious calls like <em>VirtualAlloc</em>, <em>WriteProcessMemory</em> or <em>LoadResource</em>.<figure><img src=../12-2.PNG></figure></p><p>If we take a look at the main function we can observe that the code is really simple: it manipulates the code from the resource section and follows the typical pattern of <strong>Process Replacement</strong> (creating a process in a <strong>suspended state</strong> by passing <code>CREATE_SUSPENDED (0x4)</code> as the <em>dwCreationFlags</em> parameter).</p><table><thead><tr><th style=text-align:center>main</th><th style=text-align:center>procReplacement function</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../12-2-1.PNG></figure></td><td style=text-align:center><figure><img src=../12-2-2.PNG></figure></td></tr></tbody></table><p><strong>2. How does the launcher program hide execution?</strong></p><p>As we mentioned before, the program uses process replacement technique.</p><p><strong>3. Where is the malicious payload stored?</strong></p><p>It is stored in the resource section.</p><p><strong>4. How is the malicious payload protected?</strong></p><p>It is XOR-encoded with the key 0x41 in subroutine 0x40100.<figure><img src=../12-2-5.PNG></figure><figure><img src=../12-2-4.PNG></figure></p><p><strong>5. How are strings protected?</strong></p><p>It is XOR-encoded with the key 0x41.</p><h3 id=lab-3>Lab 3</h3><p><strong>1. What is the purpose of this malicious payload?</strong></p><p>Taking a look at the imports and strings we notice something familiar, the <em>practicalmalwareanalysis.log</em> file and the hardcoded strings of keys. It is clear that we are dealing with a keylogger.<figure><img src=../12-3.PNG></figure></p><p><strong>2. How does the malicious payload inject itself?</strong></p><p>The program uses the <strong>Hook Injection</strong> technique. As we can observe, the parameter <em>dwThreadId</em> is 0, which indicates a low level hook.<figure><img src=../12-3-1.PNG></figure></p><p><strong>3. What filesystem residue does this program create?</strong></p><p>The file <em>practicalmalwareanalysis.log</em>, that saves the keystrokes.</p><h3 id=lab-4>Lab 4</h3><p><strong>1. What does the code at 0x401000 accomplish?</strong></p><p>First of all, we take a look at imports and strings.
We observe manipulation of the resource section and creation of files.</p><table><thead><tr><th style=text-align:center>Imports</th><th style=text-align:center>Strings</th></tr></thead><tbody><tr><td style=text-align:center><figure><img src=../12-4.PNG></figure></td><td style=text-align:center><figure><img src=../12-4-1.PNG></figure></td></tr></tbody></table><p>The subroutine calls <em>OpenProcess</em> with <em>winlogon.exe</em> as a parameter. Then, it compares the string &ldquo;winlogon.exe&rdquo; against &ldquo;not real&rdquo;.<figure><img src=../12-4-2.PNG></figure></p><p><strong>2. Which process has code injected?</strong></p><p>The process that has code injected is <em>winlogon.exe</em>.</p><p><strong>3. What DLL is loaded using LoadLibraryA?</strong></p><p>The library that is loaded is <em>sfc_os.dll</em> which stands for <strong>S</strong>ystem <strong>F</strong>ile <strong>C</strong>hecker utility for the Windows <strong>o</strong>perating <strong>s</strong>ystem.<figure><img src=../12-4-3.PNG></figure></p><p><strong>4. What is the fourth argument passed to the CreateRemoteThread call?</strong></p><p>The fourth argument is <em>lpStartAddress</em>.<figure><img src=../12-4-4.PNG></figure></p><p><strong>5. What malware is dropped by the main executable?</strong></p><p>After dumping the malware from the resource section with ResourceHacker, observing the strings and running it we can confirm that it a <strong>downloader</strong> that sends a request to the URL in order to get a second payload.<figure><img src=../12-4-5.PNG></figure></p><p><strong>6. What is the purpose of this and the dropped malware?</strong></p><p>As we mentioned before, the first stage of the malware injects code to <em>winlogon.exe</em> and disables <em>sfc_os.dll</em>. Apart from that, it contains a payload in its resource section. This payload is a downloader that queries &ldquo;<em>hxxp://www[.]practicalmalwareanalysis.com/updater.exe</em>&rdquo; to trojanize <em>wupdmgr.exe</em>.</p></section><div class=post-tags><nav class="nav tags"><h2 class=title>Tags</h2><ul class=tags><li><a href=/tags/practical-malware-analysis>practical malware analysis</a></li><li><a href=/tags/malware>malware</a></li><li><a href=/tags/reversing>reversing</a></li><li><a href=/tags/advanced>advanced</a></li><li><a href=/tags/static>static</a></li><li><a href=/tags/dynamic>dynamic</a></li><li><a href=/tags/analysis>analysis</a></li><li><a href=/tags/x86>x86</a></li><li><a href=/tags/assembly>assembly</a></li><li><a href=/tags/registers>registers</a></li><li><a href=/tags/ollybg>ollybg</a></li><li><a href=/tags/ghidra>ghidra</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/pabdj title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/pabdjf title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=https://es.linkedin.com/in/pablodejuanfidalgo title=LinkedIn><i data-feather=linkedin></i></a>
<a class=border></a></div><div class=footer-info>2023 © Pablo de Juan Fidalgo |</div></footer><script>feather.replace()</script></div></body></html>