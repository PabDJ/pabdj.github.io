<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Advanced Dynamic Techniques - Debugging - Pablo de Juan Fidalgo</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Notes Kernel vs. User-Mode Debugging It is more challenging to debug kernel-mode code than to debug user-mode code because you usually need two different systems for kernel mode.
Kernel debugging is performed on two systems because there is only one kernel; if the kernel is at a breakpoint, no applications can be running on the system. One system runs the code that is being debugged, and another runs the debugger. Additionally, the OS must be configured to allow for kernel debugging, and you must connect the two machines."><meta property="og:image" content><meta property="og:title" content="Advanced Dynamic Techniques - Debugging"><meta property="og:description" content="Notes Kernel vs. User-Mode Debugging It is more challenging to debug kernel-mode code than to debug user-mode code because you usually need two different systems for kernel mode.
Kernel debugging is performed on two systems because there is only one kernel; if the kernel is at a breakpoint, no applications can be running on the system. One system runs the code that is being debugged, and another runs the debugger. Additionally, the OS must be configured to allow for kernel debugging, and you must connect the two machines."><meta property="og:type" content="article"><meta property="og:url" content="https://pabdj.github.io/posts/advanced-dynamic-techniques_debugging/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-27T12:25:58+05:30"><meta property="article:modified_time" content="2022-12-27T12:25:58+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advanced Dynamic Techniques - Debugging"><meta name=twitter:description content="Notes Kernel vs. User-Mode Debugging It is more challenging to debug kernel-mode code than to debug user-mode code because you usually need two different systems for kernel mode.
Kernel debugging is performed on two systems because there is only one kernel; if the kernel is at a breakpoint, no applications can be running on the system. One system runs the code that is being debugged, and another runs the debugger. Additionally, the OS must be configured to allow for kernel debugging, and you must connect the two machines."><script src=https://pabdj.github.io/js/feather.min.js></script>
<link href=https://pabdj.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://pabdj.github.io/css/main.0fd5f05032e8d6d12808eb2d48a5a295f4ee5cd8eefd5bf3dbfd49a346d206ed.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://pabdj.github.io/css/dark.73617b6be66d271725422ddf83ec3f8c57af298005233c552735d43adf634f04.css disabled></head><body><div class=content><header><div class=main><a href=https://pabdj.github.io/>Pablo de Juan Fidalgo</a></div><nav><a href=/>Home</a>
<a href=/posts>Blog</a>
<a href=/tags>Tags</a>
| <a id=dark-mode-toggle onclick=toggleTheme() href></a>
<script src=https://pabdj.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Advanced Dynamic Techniques - Debugging</h1><div class=meta>Posted on Dec 27, 2022</div></div><section class=body><h2 id=notes>Notes</h2><h3 id=kernel-vs-user-mode-debugging>Kernel vs. User-Mode Debugging</h3><p>It is more challenging to debug kernel-mode code than to debug user-mode code because you usually need two different systems for kernel mode.</p><p>Kernel debugging is performed on two systems because there is only one kernel; if the kernel is at a breakpoint, no applications can be running on the system. One system runs the code that is being debugged, and another runs the debugger. Additionally, the OS must be configured to allow for kernel debugging, and you must connect the two machines.</p><ul><li>WinDbg is currently the only popular tool that supports kernel debugging.</li></ul><h3 id=breakpoints>Breakpoints</h3><h4 id=software-breakpoints>Software breakpoints</h4><p>Most popular debuggers set a software execution breakpoint by default. The debugger implements a software breakpoint by overwriting the first byte of an instruction with 0xCC, the instruction for INT 3, the breakpoint interrupt designed for use with debuggers. When the 0xCC instruction is executed, the OS generates an exception and transfers control to the debugger.</p><h4 id=hardware-breakpoints>Hardware breakpoints</h4><p>Every time the processor executes an instruction, there is hardware to detect if the instruction pointer is equal to the breakpoint address. Unlike software breakpoints, with hardware breakpoints, it doesn’t matter which bytes are stored at that location.</p><p>Unfortunately, hardware execution breakpoints have one major drawback: only four hardware registers store breakpoint addresses.</p><p>One further drawback of hardware breakpoints is that they are easy to modify by the running program. There are eight debug registers in the chipset, but only six are used. The first four, DR0 through DR3, store the address of a breakpoint. The debug control register (DR7) stores information on whether the values in DR0 through DR3 are enabled and whether they represent
read, write, or execution breakpoints. Malicious programs can modify these registers, often to interfere with debuggers. Thankfully, x86 chips have a feature to protect against this. By setting the General Detect flag in the DR7 register, you will trigger a breakpoint to occur prior to executing any <code>mov</code> instruction that is accessing a debug register.</p><h3 id=exceptions>Exceptions</h3><h4 id=first--and-second-chance-exceptions>First- and Second-Chance Exceptions</h4><p>When analyzing malware, you are generally not looking for bugs, so first chance exceptions can often be ignored. Malware may intentionally generate first-chance exceptions in order to make the program difficult to debug.</p><p>Second-chance exceptions cannot be ignored, because the program cannot continue running. If you encounter second-chance exceptions while debugging malware, there may be bugs in the malware that are causing it to crash, but it is more likely that the malware doesn’t like the environment in which it is running.</p></section><div class=post-tags><nav class="nav tags"><h2 class=title>Tags</h2><ul class=tags><li><a href=/tags/practical-malware-analysis>practical malware analysis</a></li><li><a href=/tags/malware>malware</a></li><li><a href=/tags/reversing>reversing</a></li><li><a href=/tags/advanced>advanced</a></li><li><a href=/tags/dynamic>dynamic</a></li><li><a href=/tags/analysis>analysis</a></li><li><a href=/tags/x86>x86</a></li><li><a href=/tags/x64>x64</a></li><li><a href=/tags/assembly>assembly</a></li><li><a href=/tags/registers>registers</a></li><li><a href=/tags/ollydbg>ollydbg</a></li><li><a href=/tags/windbg>windbg</a></li><li><a href=/tags/breakpoints>breakpoints</a></li><li><a href=/tags/kernel>kernel</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/pabdj title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/pabdjf title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=https://es.linkedin.com/in/pablodejuanfidalgo title=LinkedIn><i data-feather=linkedin></i></a>
<a class=border></a></div><div class=footer-info>2022 © Pablo de Juan Fidalgo |</div></footer><script>feather.replace()</script></div></body></html>