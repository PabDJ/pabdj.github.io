<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Malware Functionality - Data Encoding - Pablo de Juan Fidalgo</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Table of Contents Notes Simple Ciphers XOR NULL-Preserving Single-Byte XOR Encoding Other Simple Encoding Schemes Common Cryptographic Algorithms Searching for High-Entropy Content Labs Lab 1 Lab 2 Lab 3 Notes A malware author might use a layer of encoding for these purposes:
To hide configuration information, such as a command-and-control domain. To save information to a staging file before stealing it. To store strings used by the malware and decode them just before they are needed."><meta property="og:image" content><meta property="og:title" content="Malware Functionality - Data Encoding"><meta property="og:description" content="Table of Contents Notes Simple Ciphers XOR NULL-Preserving Single-Byte XOR Encoding Other Simple Encoding Schemes Common Cryptographic Algorithms Searching for High-Entropy Content Labs Lab 1 Lab 2 Lab 3 Notes A malware author might use a layer of encoding for these purposes:
To hide configuration information, such as a command-and-control domain. To save information to a staging file before stealing it. To store strings used by the malware and decode them just before they are needed."><meta property="og:type" content="article"><meta property="og:url" content="https://pabdj.github.io/posts/malwarefunctionality_dataencoding/data-encoding/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-28T00:30:58+05:30"><meta property="article:modified_time" content="2023-04-28T00:30:58+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Malware Functionality - Data Encoding"><meta name=twitter:description content="Table of Contents Notes Simple Ciphers XOR NULL-Preserving Single-Byte XOR Encoding Other Simple Encoding Schemes Common Cryptographic Algorithms Searching for High-Entropy Content Labs Lab 1 Lab 2 Lab 3 Notes A malware author might use a layer of encoding for these purposes:
To hide configuration information, such as a command-and-control domain. To save information to a staging file before stealing it. To store strings used by the malware and decode them just before they are needed."><script src=https://pabdj.github.io/js/feather.min.js></script>
<link href=https://pabdj.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://pabdj.github.io/css/main.0fd5f05032e8d6d12808eb2d48a5a295f4ee5cd8eefd5bf3dbfd49a346d206ed.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://pabdj.github.io/css/dark.73617b6be66d271725422ddf83ec3f8c57af298005233c552735d43adf634f04.css disabled></head><body><div class=content><header><div class=main><a href=https://pabdj.github.io/>Pablo de Juan Fidalgo</a></div><nav><a href=/>Home</a>
<a href=/posts>Blog</a>
<a href=/tags>Tags</a>
| <a id=dark-mode-toggle onclick=toggleTheme() href></a>
<script src=https://pabdj.github.io/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Malware Functionality - Data Encoding</h1><div class=meta>Posted on Apr 28, 2023</div></div><section class=body><h2 id=table-of-contents>Table of Contents</h2><ol><li><a href=#notes>Notes</a><ol><li><a href=#simple-ciphers>Simple Ciphers</a><ol><li><a href=#xor>XOR</a><ol><li><a href=#null-preserving-single-byte-xor-encoding>NULL-Preserving Single-Byte XOR Encoding</a></li></ol></li><li><a href=#other-simple-encoding-schemes>Other Simple Encoding Schemes</a></li></ol></li><li><a href=#common-cryptographic-algorithms>Common Cryptographic Algorithms</a><ol><li><a href=#searching-for-high-entropy-content>Searching for High-Entropy Content</a></li></ol></li></ol></li><li><a href=#labs>Labs</a><ol><li><a href=#lab-1>Lab 1</a></li><li><a href=#lab-2>Lab 2</a></li><li><a href=#lab-3>Lab 3</a></li></ol></li></ol><h2 id=notes>Notes</h2><p>A malware author might use a layer of encoding for these purposes:</p><ul><li>To hide configuration information, such as a command-and-control domain.</li><li>To save information to a staging file before stealing it.</li><li>To store strings used by the malware and decode them just before they are needed.</li><li>To disguise the malware as a legitimate tool, hiding the strings used for malicious activities.</li></ul><h3 id=simple-ciphers>Simple Ciphers</h3><h4 id=xor>XOR</h4><h5 id=null-preserving-single-byte-xor-encoding>NULL-Preserving Single-Byte XOR Encoding</h5><p>Malware authors have actually developed a clever way to mitigate this issue by using a NULL-preserving single-byte XOR encoding scheme. Unlike the regular XOR encoding scheme, the NULL-preserving single-byte XOR scheme has two exceptions:</p><ul><li>If the plaintext character is NULL or the key itself, then the byte is skipped.</li><li>If the plaintext character is neither NULL nor the key, then it is encoded via an XOR with the key.
This NULL-preserving XOR technique is especially popular in <strong>shellcode</strong>, where it is important to be able to perform encoding with a very small amount of code.</li></ul><h4 id=other-simple-encoding-schemes>Other Simple Encoding Schemes</h4><ul><li>ADD, SUB</li><li>ROL, ROR</li><li>ROT</li><li>Multibyte</li><li>Chained or loopback</li></ul><h3 id=common-cryptographic-algorithms>Common Cryptographic Algorithms</h3><p>Malware often uses simple cipher schemes because they are easy and often sufficient. Also, using standard cryptography does have potential drawbacks, particularly with regard to malware:</p><ul><li>Cryptographic libraries can be large, so malware may need to statically integrate the code or link to existing code.</li><li>Having to link to code that exists on the host may reduce portability.</li><li>Standard cryptographic libraries are easily detected (via function imports, function matching, or the identification of cryptographic constants).</li><li>Users of symmetric encryption algorithms need to worry about how to hide the key.</li></ul><div class=callout><div class=callout-inner>üí° Malware often employs the RC4 algorithm, probably because it is small and easy to implement in software, and it has no cryptographic constants to give it away.</div></div><h4 id=searching-for-high-entropy-content>Searching for High-Entropy Content</h4><p>64-byte string with 64 distinct byte values has the highest possible entropy value. The 64 values are related to the entropy value of 6 (which refers to 6 bits of entropy), since the number of values that can be expressed with 6 bits is 64.</p><p>Another setting that can be useful is a chunk size of 256 with entropy above 7.9. This means that there is a string of 256 consecutive bytes, reflecting nearly all 256 possible byte values.</p><h2 id=labs>Labs</h2><h3 id=lab-1>Lab 1</h3><p><strong>1. Compare the strings in the malware (from the output of the strings command) with the information available via dynamic analysis. Based on this comparison, which elements might be encoded?</strong></p><p>First of all, we take a look at the imports and strings via static analysis.</p><h4 id=imports>Imports</h4><figure><img src=../13-1-1.PNG></figure><h4 id=strings>Strings</h4><figure><img src=../13-1-2.PNG></figure><p>When we run the malware, we observe that it sends some HTTP requests to &ldquo;<em>hxxp://practicalmalwareanalysis[.]com</em>&rdquo; but the GET request is encoded.<figure><img src=../13-1-3.PNG></figure></p><p>It is noticeable that the sample also performs some registry manipulation.<figure><img src=../13-1-4.PNG></figure></p><p>To answer the first question, the URL in the GET requests is encoded.</p><p><strong>2. Use IDA Pro to look for potential encoding by searching for the string xor. What type of encoding do you find?</strong></p><p>We are going to do it with <a href="https://www.youtube.com/watch?v=MaxwIxrmrWY">Ghidra</a><figure><img src=../13-1-5.PNG></figure></p><p>In order to remove the XOR operations that are used to clear out registers, we are going to apply this regular expression: XOR (.*),\1<figure><img src=../13-1-6.PNG></figure><figure><img src=../13-1-7.PNG></figure><figure><img src=../13-1-8.PNG></figure></p><p>From 105 entries to 9 entries! üòÅ</p><p>If we take a look at the first one we can observe the typical loop for encoding.<figure><img src=../13-1-9.PNG></figure></p><p>It is called in subroutine located at 0x401300, which handles with the resource of the program.<figure><img src=../13-1-10.PNG></figure></p><p><strong>3. What is the key used for encoding and what content does it encode?</strong></p><p>The key that is used is 0x3B, which is number 59 in decimal, and the whole operation is done for XOR-encoding the resource attached.</p><p><strong>4. Use the static tools FindCrypt2, Krypto ANALyzer (KANAL), and the IDA Entropy Plugin to identify any other encoding mechanisms. What do you find?</strong></p><p>Ghidra also shows the entropy. In the image below, the lighter the color is, the higher the entropy. That is, grey sections contain the highest entropy (around 6.3).<figure><img src=../13-1-11.png></figure><figure><img src=../13-1-12.PNG></figure></p><p>As we can see, it is a base64 encoding string.</p><p><strong>5. What type of encoding is used for a portion of the network traffic sent by the malware?</strong></p><p>If we take a look at the strings we can observe that there are some related to a User-Agent of a browser.<figure><img src=../13-1-14.PNG></figure></p><p>It is being used in subroutine at 0x4011C9. We can suppose that this function has some network functionality, so we can take a closer look to its function call graph to get more knowledge about it.<figure><img src=../13-1-13.PNG></figure></p><p>Function at 0x4010B1 calls the base64 string function that we pointed out before, so we can assure that it is performing base64 encoding.</p><p><strong>6. Where is the Base64 function in the disassembly?</strong></p><p>At 0x4010B1.</p><p><strong>7. What is the maximum length of the Base64-encoded data that is sent? What is encoded?</strong></p><p>The function takes a buffer of 12 characters, which copies the hostname string and adds 4 additional characters.<figure><img src=../13-1-15.PNG></figure><figure><img src=../13-1-16.PNG></figure></p><p><strong>8. In this malware, would you ever see the padding characters (= or == ) in the Base64-encoded data?</strong></p><p>Yes, as it is shown in the code of the function.<figure><img src=../13-1-12.PNG></figure></p><p><strong>9. What does this malware do?</strong></p><p>This malware is a loader that contains another sample in its resource section. It is used to give an extra layer of stealthiness as it uses base64 encoding in the GET requests.</p><h3 id=lab-2>Lab 2</h3><p><strong>1. Using dynamic analysis, determine what this malware creates.</strong></p><p>First of all with static analysis we observe some suspicious imports such as <em>WriteFile</em> or <em>TerminateProcess.</em> Regarding strings, there is not anything of value.<figure><img src=../13-2-1.PNG></figure></p><p>With dynamic analysis we observe the creation of multiple files inside the directory where the malware has been run.<figure><img src=../13-2-2.PNG></figure><figure><img src=../13-2-3.PNG></figure></p><p><strong>2. Use static techniques such as a xor search, FindCrypt2, KANAL, and the IDA Entropy Plugin to look for potential encoding. What do you find?</strong></p><p>In the following picture we can observe XOR operations at different locations. As we can see, most of the calls are performed in subroutine_401739.<figure><img src=../13-2-4.PNG></figure></p><p>The subroutine has a loop that seems to be in charge of the encoding stage.<figure><img src=../13-2-5.PNG></figure></p><p><strong>3. Based on your answer to question 1, which imported function would be a good prospect for finding the encoding functions?</strong></p><p>Both <em>CreateFile</em> and <em>WriteFile</em> are functions that must be tightly related to the enconding subroutines.<figure><img src=../13-2-6.PNG></figure></p><p>For instance, function at 0x401000 is shared between them. Another thing that captured my attention was that <em>WriteFile</em> was being called in the following way:
<code>For asynchronous write operations, _hFile_ can be any handle opened with the CreateFile function using the **FILE_FLAG_OVERLAPPED**</code></p><p>After surfing for a while throughout cross-references, we manage to get a suspicious workflow. What the following image shows is that function at 0x40181F calls the XOR-encoding method and after that function at 0x401000 calls <em>CreateFile</em> and <em>WriteFile</em>.<figure><img src=../13-2-7.PNG></figure></p><p><strong>4. Where is the encoding function in the disassembly?</strong></p><p>It is located at 0x40181F.<figure><img src=../13-2-8.PNG></figure></p><p><strong>5. Trace from the encoding function to the source of the encoded content. What is the content?</strong></p><p>The encoding function is called in func_401851. As we can observe, the encoding function takes two parameters that are previously used in func_401070.<figure><img src=../13-2-9.PNG></figure></p><p>This is what we find if we dive into the function. It operates with device contexts (Windows data structure containing information about the drawing attributes of a device such as a display or a printer) and bitmaps.<figure><img src=../13-2-10.PNG></figure></p><p><strong>6. Can you find the algorithm used for encoding? If not, how can you decode the content?</strong></p><p>It is not a standard algorithm.</p><p><strong>7. Using instrumentation, can you recover the original source of one of the encoded files?</strong></p><p>The book&rsquo;s answer assumes that decoding can also be performed with the same encryption function.</p><p>The goal is to set a breakpoint before the XOR-encryption and just after its end. This means, one breakpoint at 0x00401880 (before func_40181F) and another one at 0x0040190A (after the return).<figure><img src=../13-2-9.PNG></figure></p><p>Right-click the top value on the stack in the stack pane (the value located at ESP) and select Follow in Dump. Then, with a hex editor, copy the content from one of the already encrypted files and paste in the same section of the dump with select Binary -> Binary Paste.<figure><img src=../13-2-11.png></figure></p><p>In my case the file seemed to be corrupted although the screen resolution was not changed during the process. Anyway, the goal of the lab was to practice the concepts, not retrieving the original file :)</p><h3 id=lab-3>Lab 3</h3><p><strong>1. Compare the output of strings with the information available via dynamic analysis. Based on this comparison, which elements might be encoded?</strong></p><p>The first thing to do is to obtain the strings and imports with PEStudio.</p><h4 id=imports-1>Imports</h4><figure><img src=../13-3-1.PNG></figure><h4 id=strings-1>Strings</h4><p>There are a lot of junk strings but at the end there are some of them related to cryptographic ciphers and blocks, apart from the URL &ldquo;<em>www[.]practicalmalwareanalysis[.]com</em>&rdquo; and a long string, quite similar a base64 encoding string.<figure><img src=../13-3-2.PNG></figure></p><p>Regarding dynamic analysis, we observe a request to the URL that we previously mentioned but what it stands out is the number of queries to the registers that are related to socket. Even worse, the sample <strong>modifies</strong> registry keys concerning TCP protocol.<figure><img src=../13-3-3.PNG></figure></p><p>Random TCP packets to port 8910<figure><img src=../13-3-4.PNG></figure></p><p>Registry queries to WinSocket<figure><img src=../13-3-5.PNG></figure></p><p>Registry queries to TCP protocol<figure><img src=../13-3-6.PNG></figure><figure><img src=../13-3-7.PNG></figure></p><p>To answer the question: network parameters seem to be encoded.</p><p><strong>2. Use static analysis to look for potential encoding by searching for the string xor. What type of encoding do you find?</strong></p><p>If we look for potential encoding by searching the string <em>xor</em> we collect more results than in the previous labs.<figure><img src=../13-3-8.PNG></figure><figure><img src=../13-3-9.PNG></figure></p><p>First of all, we land to main, and the first thing that we notice is a call to func_401AC2, which is one of the subroutines that has several calls to XOR operation.<figure><img src=../13-3-10.PNG></figure></p><p>Diving into this function we observe all the <em>magic</em>. Ghidra detects AES encryption apart from the appearance of several strings related to keys, that were detected via static analysis.<figure><img src=../13-3-11.PNG></figure><figure><img src=../13-3-12.PNG></figure></p><p><strong>3. Use static tools like FindCrypt2, KANAL, and the IDA Entropy Plugin to identify any other encoding mechanisms. How do these findings compare with the XOR findings?</strong></p><p>Ghidra detects an area with 8.0 as entropy value (red part). From 0x40EB54 to 0x40F7BD.<figure><img src=../13-3-13.PNG></figure></p><p><strong>4. Which two encoding techniques are used in this malware?</strong></p><p>Base64 (at 0x40103F) and AES encryption.</p><p><strong>5. For each encoding technique, what is the key?</strong></p><p>The key for base64 is <em>CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/</em> and the one for AES is <em>ijklmnopqrstuvwx</em>.</p><p><strong>6. For the cryptographic encryption algorithm, is the key sufficient? What else must be known?</strong></p><p>For AES, also the length of the key and the length of block must be provided.</p><p><strong>7. What does this malware do?</strong></p><p>As we can observe in the function call graph from main subroutine we appreciate encryption algorithms and network connections through socket. This communication is encrypted, and it is done via a shell process.<figure><img src=../13-3-14.PNG></figure><figure><img src=../13-3-15.PNG></figure></p></section><div class=post-tags><nav class="nav tags"><h2 class=title>Tags</h2><ul class=tags><li><a href=/tags/practical-malware-analysis>practical malware analysis</a></li><li><a href=/tags/malware>malware</a></li><li><a href=/tags/reversing>reversing</a></li><li><a href=/tags/advanced>advanced</a></li><li><a href=/tags/static>static</a></li><li><a href=/tags/dynamic>dynamic</a></li><li><a href=/tags/analysis>analysis</a></li><li><a href=/tags/x86>x86</a></li><li><a href=/tags/assembly>assembly</a></li><li><a href=/tags/registers>registers</a></li><li><a href=/tags/ollybg>ollybg</a></li><li><a href=/tags/ghidra>ghidra</a></li><li><a href=/tags/xor-encoding>xor encoding</a></li><li><a href=/tags/aes-encryption>aes encryption</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/pabdj title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/pabdjf title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=https://es.linkedin.com/in/pablodejuanfidalgo title=LinkedIn><i data-feather=linkedin></i></a>
<a class=border></a></div><div class=footer-info>2023 ¬© Pablo de Juan Fidalgo |</div></footer><script>feather.replace()</script></div></body></html>