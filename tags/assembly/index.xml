<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>assembly on Pablo de Juan Fidalgo</title><link>https://pabdj.github.io/tags/assembly/</link><description>Recent content in assembly on Pablo de Juan Fidalgo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Â© Pablo de Juan Fidalgo</copyright><lastBuildDate>Mon, 19 Dec 2022 09:50:58 +0530</lastBuildDate><atom:link href="https://pabdj.github.io/tags/assembly/index.xml" rel="self" type="application/rss+xml"/><item><title>Advanced Static Techniques - x86 Disassembly</title><link>https://pabdj.github.io/posts/advanced-static-techniques-_-x86-disassembly/</link><pubDate>Mon, 19 Dec 2022 09:50:58 +0530</pubDate><guid>https://pabdj.github.io/posts/advanced-static-techniques-_-x86-disassembly/</guid><description>This blog post collects some notes that I took while reading PMA Chapter 4. As it was not the first time dealing with assembly most of the concepts rang a bell.
Opcodes and Endianness Network data uses big-endian and an x86 program uses little-endian. Therefore, the IP address 127.0.0.1 will be represented as 0x7F000001 in big endian format (over the network) and 0x0100007F in little-endian format (locally in memory)
Registers General registers Some x86 instructions use specific registers by definition.</description></item></channel></rss>