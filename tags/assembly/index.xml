<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>assembly on Pablo de Juan Fidalgo</title><link>https://pabdj.github.io/tags/assembly/</link><description>Recent content in assembly on Pablo de Juan Fidalgo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© Pablo de Juan Fidalgo</copyright><lastBuildDate>Fri, 24 Mar 2023 19:53:58 +0530</lastBuildDate><atom:link href="https://pabdj.github.io/tags/assembly/index.xml" rel="self" type="application/rss+xml"/><item><title>Advanced Dynamic Techniques - WinDbg</title><link>https://pabdj.github.io/posts/advanceddynamictechniques_windbg/advanceddynamictechniques_windbg/</link><pubDate>Fri, 24 Mar 2023 19:53:58 +0530</pubDate><guid>https://pabdj.github.io/posts/advanceddynamictechniques_windbg/advanceddynamictechniques_windbg/</guid><description>Table of Contents Notes Drivers and Kernel Code Setting Up Kernel Debugging Windows XP and x86 architecture Windows Vista, Windows 7, and x64 Versions Using WinDbg Microsoft Symbols Kernel Debugging in Practice User-space code Kernel-space code Loading Drivers Labs Lab 1 Lab 2 Lab 3 Notes Drivers and Kernel Code Drivers must be loaded into the kernel, just as DLLs are loaded into processes. When a driver is first loaded, its DriverEntry procedure is called, similar to DLLMain for DLLs.</description></item><item><title>Advanced Dynamic Techniques - OllyDbg</title><link>https://pabdj.github.io/posts/advanceddynamictechniques_ollydbg/advanceddynamictechniques_ollydbg/</link><pubDate>Wed, 11 Jan 2023 15:20:58 +0530</pubDate><guid>https://pabdj.github.io/posts/advanceddynamictechniques_ollydbg/advanceddynamictechniques_ollydbg/</guid><description>Table of Contents Notes Memory map Breakpoints Loading DLLs Labs Lab 1 Lab 2 Lab 3 Notes Memory map All PE files in Windows have a preferred base address, known as the image base defined in the PE header. The image base isn’t necessarily the address where the malware will be loaded, although it usually is. Most executables are designed to be loaded at 0x00400000, which is just the default address used by many compilers for the Windows platform.</description></item><item><title>Advanced Dynamic Techniques - Debugging</title><link>https://pabdj.github.io/posts/advanced-dynamic-techniques_debugging/</link><pubDate>Tue, 27 Dec 2022 12:25:58 +0530</pubDate><guid>https://pabdj.github.io/posts/advanced-dynamic-techniques_debugging/</guid><description>Table of Contents Kernel vs. User-Mode Debugging Breakpoints Software breakpoints Hardware breakpoints Exceptions First- and Second-Chance Exceptions Notes Kernel vs. User-Mode Debugging It is more challenging to debug kernel-mode code than to debug user-mode code because you usually need two different systems for kernel mode.
Kernel debugging is performed on two systems because there is only one kernel; if the kernel is at a breakpoint, no applications can be running on the system.</description></item><item><title>Advanced Static Techniques - Analyzing Malicious Windows Programs</title><link>https://pabdj.github.io/posts/advancedstatictechniques_analyzing_malicious_windows_programs/advancedstatictechniques_analyzingmaliciouswindowsprograms/</link><pubDate>Mon, 26 Dec 2022 14:25:58 +0530</pubDate><guid>https://pabdj.github.io/posts/advancedstatictechniques_analyzing_malicious_windows_programs/advancedstatictechniques_analyzingmaliciouswindowsprograms/</guid><description>Table of Contents Notes Windows API types Windows Registry Registry Root Keys Networking APIs Following running malware Kernel vs. User Mode The Native API Labs Lab 1 Lab 2 Lab 3 Notes DWORD and WORD types represent 32-bit and 16-bit unsigned integers. Windows does not use int, short or unsigned. Windows API types Handles (H). A reference to an object. Long Pointer (LP). A pointer to another type. CreateFile. This function is used to create and open files.</description></item><item><title>Advanced Static Techniques - Recognizing C code constructs in Assembly</title><link>https://pabdj.github.io/posts/advancedstatictechniques_c_code_constructs_in_assembly/advancedstatictechniques_recognizingccodeconstructsinassembly/</link><pubDate>Sat, 24 Dec 2022 14:15:58 +0530</pubDate><guid>https://pabdj.github.io/posts/advancedstatictechniques_c_code_constructs_in_assembly/advancedstatictechniques_recognizingccodeconstructsinassembly/</guid><description>Table of Contents Notes Global vs. Local Variables Understanding Function Call Conventions Labs Lab 1 Lab 2 Lab 3 Lab 4 Notes Global vs. Local Variables Global variables are referenced by memory addresses, and the local variables are referenced by the stack addresses. Understanding Function Call Conventions cdecl is one of the most popular conventions. In cdecl, parameters are pushed onto the stack from right to left, the caller cleans up the stack when the function is complete, and the return value is stored in EAX.</description></item><item><title>Advanced Static Techniques - IDA Pro and Ghidra</title><link>https://pabdj.github.io/posts/advancedstatictechniques_idapro/advancedstatictechniques_idapro/</link><pubDate>Wed, 21 Dec 2022 19:30:58 +0530</pubDate><guid>https://pabdj.github.io/posts/advancedstatictechniques_idapro/advancedstatictechniques_idapro/</guid><description>Table of Contents Notes The IDA Pro Interface Ghidra Modifications References Labs Lab 1 This chapter is about learning the powerful tool called IDA Pro. Unfortunately, this tool requires an expensive license, so I will try to apply all the content from the book into Ghidra.
In My Awesome List there are multiple pointers to interesting tricks and tips to enhance Ghidra. Apart from that, in Create your own malware analysis lab - Upgrading FLARE VM there is a link to several scripts that are thought to provide a similar experience to IDA Pro.</description></item><item><title>Advanced Static Techniques - x86 Disassembly</title><link>https://pabdj.github.io/posts/advanced-static-techniques-_-x86-disassembly/</link><pubDate>Mon, 19 Dec 2022 09:50:58 +0530</pubDate><guid>https://pabdj.github.io/posts/advanced-static-techniques-_-x86-disassembly/</guid><description>Table of Contents Opcodes and Endianness Registers General registers Simple instructions The Stack This blog post collects some notes that I took while reading PMA Chapter 4. As it was not the first time dealing with assembly most of the concepts rang a bell.
Opcodes and Endianness Network data uses big-endian and an x86 program uses little-endian. Therefore, the IP address 127.0.0.1 will be represented as 0x7F000001 in big endian format (over the network) and 0x0100007F in little-endian format (locally in memory)</description></item></channel></rss>